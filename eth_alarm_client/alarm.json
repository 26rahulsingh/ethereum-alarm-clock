{
    "Alarm": {
        "code": "0x606060405260008054600160a060020a03191673fe9d4e5717ec0e16f8301240df5c3f7d3e9effef179055606061016e806100c3833901809050604051809103906000f060405160028054600160a060020a0319169290921790915561016e80610231833901809050604051809103906000f060405160038054600160a060020a03191692909217909155610eae8061039f833901809050604051809103906000f0600b8054600160a060020a0319169190911790556118ec8061124d6000396000f3606060405260008054600160a060020a0319163317905561014a806100246000396000f3606060405260e060020a6000350463e8b1d0f3811461001b575b005b60806020601f6044356004818101359283018490049093028401604052606082815261009e949335936024803594606494909101918190838280828437509495505050505050600080543373ffffffffffffffffffffffffffffffffffffffff9081169116146100b0576100b06000806001815481101561000257505080805250565b60408051918252519081900360200190f35b8373ffffffffffffffffffffffffffffffffffffffff168360e060020a9004836040518260e060020a028152600401808280519060200190808383829060006004602084601f0104600302600f01f150905090810190601f1680156101295780820380516001836020036101000a031916815260200191505b509150506000604051808303816000876161da5a03f197965050505050505056606060405260008054600160a060020a0319163317905561014a806100246000396000f3606060405260e060020a6000350463e8b1d0f3811461001b575b005b60806020601f6044356004818101359283018490049093028401604052606082815261009e949335936024803594606494909101918190838280828437509495505050505050600080543373ffffffffffffffffffffffffffffffffffffffff9081169116146100b0576100b06000806001815481101561000257505080805250565b60408051918252519081900360200190f35b8373ffffffffffffffffffffffffffffffffffffffff168360e060020a9004836040518260e060020a028152600401808280519060200190808383829060006004602084601f0104600302600f01f150905090810190601f1680156101295780820380516001836020036101000a031916815260200191505b509150506000604051808303816000876161da5a03f197965050505050505056606060405260008054600160a060020a03191633179055610e8a806100246000396000f3606060405236156100e55760e060020a600035046319f74e1f811461012957806323306ed614610147578063299179541461015257806350a3bd391461015e5780635ae348681461016a5780636595f73a14610175578063741b3c391461019057806384c92c9a146101985780638dd5e298146101ad578063910789c4146101bf5780639d12f0f5146101fc578063a6814e8e14610250578063aec918c71461025f578063b010d94a1461027f578063bc966ddc14610294578063c3daab961461029f578063c4afc3fb146102ae578063c861cd66146102c9578063e8543d0d146102e1575b6103265b61032833345b600160a060020a0382166000908152600160205260409020548082011015610359576103595b600080600181548110156100025750508052565b61032a6004356024355b60006000600083600014156108225761081a565b61032a5b3a45025b90565b61032661099333610286565b610326610957336101b4565b61032a61020061014f565b61032a6004356000818152600360205260409020545b919050565b6103266100e9565b61032a6004355b60006107f733610809610254565b61032a6004355b60006108928261019f565b61032a60043560028054829081101561000257506000527f405787fa12a823e0f2b7631cc41b3ba8828b3321ca811111fa75cd3aa3bb5ace015481565b61032660043560243560443560643560006000600060006000600060006000600060009054906101000a9004600160a060020a0316600160a060020a031633600160a060020a03161415156104de57610576565b61032a5b600061079b43610266565b61032a6004355b600060006000600260005054600014156107335761072c565b61032a6004355b600061090682610809610254565b61032a61010061014f565b61032660043561037b3361019f565b61032a5b60006000600260005054600014156107ab576107a7565b61032a60043560016020526000908152604090205481565b61033c6004356024356044356064355b6000600060006000600060008887108061030f57508760ff16890187115b1561045657600095505b5050505050949350505050565b005b565b60408051918252519081900360200190f35b60408051600160a060020a03929092168252519081900360200190f35b600160a060020a03821660009081526001602052604090208054820190555050565b156103d657600160a060020a0333166000908152600160205260409020548111156103a8576103a8610115565b6103b061014b565b600160a060020a03331660009081526001602052604090205482900310156103d6575b50565b61040433825b600160a060020a0382166000908152600160205260409020548111156109bc576109bc610115565b604051600160a060020a03331690600090839082818181858883f1935050505015156103d35733600160a060020a03165a60405183906000818181858888f1935050505015156103d3576103d3610115565b61045f89610266565b945084600014156104735760009550610319565b60008581526003602052604090209350600460ff89811682900416935089880304915060028201839011156104ab5760009550610319565b508254808a069084908284018190069081101561000257600091825260209091200154600160a060020a03169550610319565b6104e78a610266565b60008181526003602052604090209098509650600460ff8a8116829004169350438b90030491506002820183901115610526576105358b8b8b8d6102f1565b60028754101561061857610576565b8a965090505b60ff89168a018611610576576105538b8b8b896102f1565b9350600160a060020a038481169082161480156105705750898614155b156105e5575b505050505050505050505050565b604080518d815243602082015280820183905290519196508991600160a060020a038f811692908816917f47d4e871a02baa58fd74fe0787c713589a0ce351d4c70ffe2d0f10353fab9fe59181900360600190a45b6004959095019461053b565b8b600160a060020a031684600160a060020a03161415610604576105d9565b610584848d5b6000600060006109df61014b565b600095505b8654861015610576578b600160a060020a03168787815481101561000257600091825260209091200154600160a060020a0316141561068857868754600189548901030681548110156100025760206000200154600160a060020a031694506106949050848d61060a565b6001959095019461061d565b604080518d815243602082015280820183905290519196508991600160a060020a038f811692908816917f47d4e871a02baa58fd74fe0787c713589a0ce351d4c70ffe2d0f10353fab9fe59181900360600190a46106f06102b2565b60001415610706576107065b6000610a256102b2565b610576846107126102b2565b600060008260001415610cab57610cab610115565b600092505b5050919050565b600091505b60025482101561072757600280548381036000190190811015610002576000919091527f405787fa12a823e0f2b7631cc41b3ba8828b3321ca811111fa75cd3aa3bb5ace0154905083811161078f5780925061072c565b60019190910190610738565b905061014f565b600091505b5090565b60028054600019810190811015610002576000919091527f405787fa12a823e0f2b7631cc41b3ba8828b3321ca811111fa75cd3aa3bb5ace01549050438111156107a2578091506107a7565b8061080e575061080e336108096102b2565b610133565b905061018b565b600092505b505092915050565b600084815260036020526040812080549093501415610844576000925061081a565b5060005b81548110156108155784600160a060020a03168282815481101561000257600091825260209091200154600160a060020a0316141561088a576001925061081a565b600101610848565b1561089f5750600061018b565b6108a76102b2565b6000141580156108c257506101006108bd6102b2565b034310155b156108cf5750600061018b565b6108d761014b565b600160a060020a03831660009081526001602052604090205410156108fe5750600061018b565b50600161018b565b15156109145750600061018b565b61091c6102b2565b6000146108fe5761010061092e6102b2565b03431061093d5750600061018b565b610949826108096102b2565b15156108fe5750600061018b565b15610328576109646102b2565b60001415610974576109746106fc565b610328336109806102b2565b60008160001415610c1657610c16610115565b15610328576109a06102b2565b600014156109b0576109b06106fc565b610328336107126102b2565b600160a060020a0382166000908152600160205260409020805482900390555050565b600160a060020a038616600090815260016020526040902054909250905080821115610a09579050805b610a1385836103dc565b610a1d84836100ef565b81925061081a565b600014610a3457610a34610115565b50610200430160036000610a46610254565b81526020818101929092526040908101600090812084825260038452918120825481548183558284529490922090938101928215610aa55760005260206000209182015b82811115610aa5578254825591600101919060010190610a8a565b50610acb9291505b808211156107a7578054600160a060020a0319168155600101610aad565b5050610b188160008181526003602052604081209080805b8354811015610dd2578354604080514340815260208101849052815190819003909101902006925082811415610dd957610e82565b6002805460018101808355919082908015829011610b5957818360005260206000209182019101610b5991905b808211156107a75760008155600101610b45565b505060028054849350909150600019810190811015610002575080546000919091527f405787fa12a823e0f2b7631cc41b3ba8828b3321ca811111fa75cd3aa3bb5acd015550565b50505050828160018354038154811015610002575050815460008381526020812091909101600019018054600160a060020a0319169092179091556040518391600160a060020a038616917fa192e48a82f18ef1c93e722713426e5733e98d5b2858ba5c7457faf4a8297dab9190a35b505050565b610c208383610133565b15610c2a57610c11565b50600081815260036020526040902080546001810180835590829082908015829011610ba157818360005260206000209182019101610ba19190610b45565b505050505b6040518390600160a060020a038616907feee53013e70e8b24433023a137d553d5fc6a714de816654052b177b9806f35bf90600090a35b50505050565b610cb58484610133565b1515610cc057610ca5565b6000838152600360205260409020805490925060011415610d0a5760008281815481835581811511610d0557818360005260206000209182019101610d059190610b45565b505050505b5060005b8154811015610c6e5783600160a060020a03168282815481101561000257600091825260209091200154600160a060020a03161415610dca57816001835403815481101561000257906000526020600020900160009054906101000a9004600160a060020a031682828154811015610002576020600020018054600160a060020a031916909217909155508154600019810180845590839082908015829011610c6957818360005260206000209182019101610c699190610b45565b600101610d0e565b5050505050565b8381815481101561000257508054600082815260209020830154600160a060020a03169350849081101561000257906000526020600020900160009054906101000a9004600160a060020a0316848281548110156100025750602060002083018054600160a060020a03191690921790915550835482908590859081101561000257906000526020600020900160006101000a815481600160a060020a03021916908302179055505b600101610ae356606060405236156101d75760e060020a600035046303d6d7b6811461021a578063086ae9e41461024657806309c975df146102645780631145a20f1461028757806312d67c5f146102a85780631302188c146102b2578063234917d4146102bd5780632a472ae8146102da5780632e1a7d4d1461030157806332b212551461033157806334c19b93146103c257806335b28153146103e25780633664a0ea1461043057806352afbc331461043b57806353a0dc7d146104645780635539d400146104d757806360b831e5146104eb578063662fc8a01461051e578063685c234a146105325780636ff96d171461057f5780636ffc08961461059757806375428615146105be57806377b19cd51461064957806378bc6460146106675780638b37e6561461068457806394d2b21b146106aa57806394f3f81d146106be578063a152a2ba14610709578063a9743c681461071d578063aa4cc01f1461073a578063b0ac4c8c14610761578063b0f07e44146107d2578063cd06273414610817578063da0774ad14610841578063da2b861614610862578063e409865514610880578063f340fa011461089d578063f828c3fa146108ad578063f9f447eb146108cc578063fc300522146108e9578063fcf3691814610906575b6109ab6109ad33345b600160a060020a0382166000908152600160205260409020548082011015610a8c57610a8c5b600080600181548110156100025750508052565b6109ef6004355b60008181526006602081905260408220908101543a458102918491611639919061084b565b6109ef6004356000818152600660205260409020600801545b919050565b610a01600435600081815260066020526040902054600160a060020a031661025f565b6109ab60043560243560443560643560843561166885858585856000610451565b6109ef6008545b90565b6109ef6009546102af565b6109ef60043560008181526006602052604090206003015461025f565b6109ef6004356000818152600660205260409020600c015460c860020a900460ff1661025f565b6109ab600435600160a060020a033316600090815260016020526040902054819010610afb57610afe3382610b67565b6109ef60408051600080547fd2bbf6df00000000000000000000000000000000000000000000000000000000835230600160a060020a039081166004850152608860020a6e63616c6c546172676574426c6f636b02602485015293519193169163d2bbf6df916044828101926020929190829003018187876161da5a03f115610002575050506040515190506102af565b6109ef60043560008181526006602052604090206004015460ff1661025f565b6109ab60043560408051600160a060020a03838116606060020a9081028352339190911602601482015281519081900360280190206000908152600460205220805460ff1916600117905550565b6109ef6005546102af565b6109ab60043560243560443560643560843560a4355b6000600061166f3389898989898961047d565b6109ef60043560243560443560643560843560a43560c4355b60408051600160a060020a03988916606060020a90810282529790981690960260148801526028870194909452602c860192909252604c85015260ff1660f860020a02606c840152606d8301525190819003608d01902090565b610a01600354600160a060020a03166102af565b6109ab60043560008181526006602052604090206001810154600160a060020a0390811633919091161461184d57610aab565b610a01600b54600160a060020a03166102af565b6109ef6004356024355b60408051600160a060020a03848116606060020a9081028352908416026014820152815190819003602801902060009081526004602052205460ff165b92915050565b6109ef60043560016020526000908152604090205481565b6109ef6004356000818152600660205260409020600c015460d060020a900460ff1661025f565b610a1e6004355b6040805160208181018352600080835284815260068252838120600d01548152600a825283902080548451601f8201849004840281018401909552808552929392909183018282801561063d57820191906000526020600020905b81548152906001019060200180831161062057829003601f168201915b5050505050905061025f565b6109ef6004356000818152600660208190526040909120015461025f565b6109ef60043560008181526006602052604090206007015461025f565b610a01600435600081815260066020526040902060010154600160a060020a031661025f565b610a01600254600160a060020a03166102af565b6109ab60043560408051600160a060020a03838116606060020a9081028352339190911602601482015281519081900360280190206000908152600460205220805460ff1916905550565b610a01600054600160a060020a03166102af565b6109ef6004356000818152600660205260409020600a015461025f565b6109ef6004356000818152600660205260409020600c015460c060020a900460ff1661025f565b610a1e604080516020818101835260008252825160078054601f810184900484028301840190955284825292939092918301828280156107c657820191906000526020600020905b8154815290600101906020018083116107a957829003601f168201915b505050505090506102af565b6007805460031936018083556109ab9260009282908015829011610bd157601f016020900481601f01602090048360005260206000209182019101610bd19190610c5a565b6109ef6004356000818152600660205260409020600c015460a060020a900460e060020a0261025f565b6109ef6004356024355b60008282111561164d578183606402049050610579565b6109ef608860020a6e63616c6c546172676574426c6f636b026102af565b6109ef60043560008181526006602052604090206002015461025f565b6109ab600435610aaf81346101e0565b6109ab6004356024356044356064356116628484848460ff6000610451565b6109ef6004356000818152600660205260409020600d015461025f565b6109ef6004356000818152600660205260409020600b015461025f565b6109ab60043560006000600060006000602060405190810160405280600081526020015060005a888252600660205260408220600c810154919850965060c860020a900460ff1615610e1d57604080517f414c52454144592043414c4c4544000000000000000000000000000000000000815290518991600160a060020a033316916000805160206118cc8339815191529181900360200190a35b5050505050505050565b005b604080513481529051600160a060020a0333169182917f5548c837ab068cf56a2c2479df0882a4922fd203edb7517321831d95078c5f629181900360200190a3565b60408051918252519081900360200190f35b60408051600160a060020a03929092168252519081900360200190f35b60405180806020018281038252838181518152602001915080519060200190808383829060006004602084601f0104600302600f01f150905090810190601f168015610a7e5780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b600160a060020a03821660009081526001602052604090208054820190555b5050565b80600160a060020a031633600160a060020a03167f5548c837ab068cf56a2c2479df0882a4922fd203edb7517321831d95078c5f62346040518082815260200191505060405180910390a35b50565b604051600160a060020a03331690600090839082818181858883f193505050501515610b8f5733600160a060020a03165a60405183906000818181858888f193505050501515610b8f57610b8f610206565b60018701549092506112fc90600160a060020a0316865b600160a060020a0382166000908152600160205260409020548111156118a9576118a9610206565b604080518281529051600160a060020a033316917f884edad9ce6fa2440d8a54cc123490eb96d2768479d49ff9c7366125a9424364919081900360200190a250565b50505060043611159050610c72575060005b600754811015610c7257600060048201368110156100025790013560f860020a900460f860020a026007600050828154811015610002579060005260206000209060209182820401919006601f036101000a81548160ff0219169060f860020a84040217905550600101610be3565b50610d3a9291505b80821115610c6e5760008155600101610c5a565b5090565b6007600050600a60005060006007600050604051808280548015610ccb57908552017fa66cc928b5edb82af9bd49922954155ab7b0942694bea4ce44661d9a8736c688825b815481529060010190602001808311610cb7575b50509150506040518091039020815260200190815260200160002060005090805482805482825590600052602060002090601f01602090048101928215610c5257600052602060002091601f016020900482015b82811115610c52578254825591600101919060010190610d1f565b50506007600050604051808280548015610d8c57600091909152017fa66cc928b5edb82af9bd49922954155ab7b0942694bea4ce44661d9a8736c688825b815481529060010190602001808311610d78575b5050604051908190039020600955505060078054600881905560008290526020601f8201047fa66cc928b5edb82af9bd49922954155ab7b0942694bea4ce44661d9a8736c6889081019190838215610e0c57600052602060002091601f016020900482015b82811115610e0c578254825591600101919060010190610df1565b50610e18929150610c5a565b505050565b600c86015460c060020a900460ff1615610e8457604080517f43414e43454c4c45440000000000000000000000000000000000000000000000815290518991600160a060020a033316916000805160206118cc8339815191529181900360200190a36109a1565b8554600160a060020a031660001415610eea57604080517f554e4b4e4f574e00000000000000000000000000000000000000000000000000815290518991600160a060020a033316916000805160206118cc8339815191529181900360200190a36109a1565b6003860154431015610f4957604080517f544f4f204541524c590000000000000000000000000000000000000000000000815290518991600160a060020a033316916000805160206118cc8339815191529181900360200190a36109a1565b6003860154600487015460ff1601431115610fb157604080517f544f4f204c415445000000000000000000000000000000000000000000000000815290518991600160a060020a033316916000805160206118cc8339815191529181900360200190a36109a1565b610fba88610221565b600187810154600160a060020a0316600090815260209190915260409020549095508590101561104f57600c8601805460c860020a60ff02191660c860020a179055604080517f494e53554646494349454e545f46554e44530000000000000000000000000000815290518991600160a060020a033316916000805160206118cc8339815191529181900360200190a36109a1565b60408051600b547fa6814e8e0000000000000000000000000000000000000000000000000000000082529151600092600160a060020a031691636595f73a91839163a6814e8e916004828101926020929190829003018189876161da5a03f1156100025750506040805180517f6595f73a0000000000000000000000000000000000000000000000000000000082526004820152905160248281019350602092829003018187876161da5a03f115610002575050506040515111156112c65760408051600b54600389015460048a8101547fe8543d0d0000000000000000000000000000000000000000000000000000000085529084018d9052602484019190915260ff1660448301524360648301529151600160a060020a03929092169163e8543d0d9160848181019260209290919082900301816000876161da5a03f1156100025750505060405151935083600160a060020a03166000141580156111c8575033600160a060020a031684600160a060020a031614155b1561122057604080517f57524f4e475f43414c4c45520000000000000000000000000000000000000000815290518991600160a060020a033316916000805160206118cc8339815191529181900360200190a36109a1565b60048660030160005054430304925060008311156112c657604080516003880154600b5460048a8101547f9d12f0f5000000000000000000000000000000000000000000000000000000008552600160a060020a0333811692860192909252602485018e9052604485019390935260ff9290921660648401529251921691639d12f0f591608481810192600092909190829003018183876161da5a03f115610002575050505b3a6007870155600c8601805473ffffffffffffffffffffffffffffffffffffffff191633179055436002870155610b50886105c5565b8554600187015461131991600160a060020a03918216911661053c565b1561142a57600354600160a060020a031663e8b1d0f3620236565a038860000160009054906101000a9004600160a060020a031689600c0160149054906101000a900460e060020a02866040518560e060020a0281526004018084600160a060020a03168152602001838152602001806020018281038252838181518152602001915080519060200190808383829060006004602084601f0104600302600f01f150905090810190601f1680156113e45780820380516001836020036101000a031916815260200191505b5094505050505060206040518083038160008887f11561000257505060405151600c8901805460d060020a60ff02191660d060020a909202919091179055506115319050565b600254600160a060020a031663e8b1d0f3620236565a038860000160009054906101000a9004600160a060020a031689600c0160149054906101000a900460e060020a02866040518560e060020a0281526004018084600160a060020a03168152602001838152602001806020018281038252838181518152602001915080519060200190808383829060006004602084601f0104600302600f01f150905090810190601f1680156114f05780820380516001836020036101000a031916815260200191505b5094505050505060206040518083038160008887f11561000257505060405151600c8901805460d060020a60ff02191660d060020a90920291909117905550505b600186015461154990600160a060020a0316866101e0565b600c8601805460c860020a60ff02191660c860020a1790556040518890600160a060020a033316907fed1062ba7ed13514b41ef115d3c324f50dcd644da75ee5659e9ae97071774f1e90600090a3600686015460078701546115ab919061084b565b905062024e3a5a880301600887018190556007870154026009870181905561271090820260658102829004600a8901819055919004600b8801819055600188015461160392600160a060020a03919091169101610b67565b6116143387600a01600050546101e0565b6109a173d3cda913deb6f67967b99d67acdfa1712c29360187600b01600050546101e0565b612710920260660291909104949350505050565b818360020203836064020460c8039050610579565b50505050565b5050505050565b91507fc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a47086148015906116ad57506000868152600a6020526040812054145b156116b7576109a1565b602843018510156116c7576109a1565b50600081815260066020526040812080549091600160a060020a0391909116146116f0576109a1565b60108460ff161015611701576109a1565b6005828155815473ffffffffffffffffffffffffffffffffffffffff199081168a17835560018301805490911633179055818101849055600c8201805477ffffffff0000000000000000000000000000000000000000191660a060020a60e060020a8b0402179055600d8201879055600382018690556004828101805460ff1916871790553a6006840155600080549254604080517f870e5405000000000000000000000000000000000000000000000000000000008152608860020a6e63616c6c546172676574426c6f636b029481019490945260248401919091526044830189905251600160a060020a03939093169263870e5405926064818101939291829003018183876161da5a03f11561000257505060405160055491507f5ca1bad5a7f3ee229aa045a13d9936a9a5f7f70067a0e39bdb8a6c0086b1544c90600090a25050505050505050565b600c81015460c860020a900460ff161561186657610aab565b600381015443600719919091011161187d57610aab565b600c01805478ff000000000000000000000000000000000000000000000000191660c060020a17905550565b600160a060020a03821660009081526001602052604090208054829003905550505684b46e45ca3bd189c011a16ca05a10d3520bc4802b03a59efd78a568a20fedfe",
        "info": {
            "abiDefinition": [
                {
                    "constant": true,
                    "inputs": [
                        {
                            "name": "callKey",
                            "type": "bytes32"
                        }
                    ],
                    "name": "getCallMaxCost",
                    "outputs": [
                        {
                            "name": "",
                            "type": "uint256"
                        }
                    ],
                    "type": "function"
                },
                {
                    "constant": true,
                    "inputs": [
                        {
                            "name": "callKey",
                            "type": "bytes32"
                        }
                    ],
                    "name": "getCallGasUsed",
                    "outputs": [
                        {
                            "name": "",
                            "type": "uint256"
                        }
                    ],
                    "type": "function"
                },
                {
                    "constant": true,
                    "inputs": [
                        {
                            "name": "callKey",
                            "type": "bytes32"
                        }
                    ],
                    "name": "getCallContractAddress",
                    "outputs": [
                        {
                            "name": "",
                            "type": "address"
                        }
                    ],
                    "type": "function"
                },
                {
                    "constant": false,
                    "inputs": [
                        {
                            "name": "contractAddress",
                            "type": "address"
                        },
                        {
                            "name": "abiSignature",
                            "type": "bytes4"
                        },
                        {
                            "name": "dataHash",
                            "type": "bytes32"
                        },
                        {
                            "name": "targetBlock",
                            "type": "uint256"
                        },
                        {
                            "name": "gracePeriod",
                            "type": "uint8"
                        }
                    ],
                    "name": "scheduleCall",
                    "outputs": [],
                    "type": "function"
                },
                {
                    "constant": true,
                    "inputs": [],
                    "name": "getLastDataLength",
                    "outputs": [
                        {
                            "name": "",
                            "type": "uint256"
                        }
                    ],
                    "type": "function"
                },
                {
                    "constant": true,
                    "inputs": [],
                    "name": "getLastDataHash",
                    "outputs": [
                        {
                            "name": "",
                            "type": "bytes32"
                        }
                    ],
                    "type": "function"
                },
                {
                    "constant": true,
                    "inputs": [
                        {
                            "name": "callKey",
                            "type": "bytes32"
                        }
                    ],
                    "name": "getCallTargetBlock",
                    "outputs": [
                        {
                            "name": "",
                            "type": "uint256"
                        }
                    ],
                    "type": "function"
                },
                {
                    "constant": true,
                    "inputs": [
                        {
                            "name": "callKey",
                            "type": "bytes32"
                        }
                    ],
                    "name": "checkIfCalled",
                    "outputs": [
                        {
                            "name": "",
                            "type": "bool"
                        }
                    ],
                    "type": "function"
                },
                {
                    "constant": false,
                    "inputs": [
                        {
                            "name": "value",
                            "type": "uint256"
                        }
                    ],
                    "name": "withdraw",
                    "outputs": [],
                    "type": "function"
                },
                {
                    "constant": true,
                    "inputs": [],
                    "name": "getGroveIndexId",
                    "outputs": [
                        {
                            "name": "",
                            "type": "bytes32"
                        }
                    ],
                    "type": "function"
                },
                {
                    "constant": true,
                    "inputs": [
                        {
                            "name": "callKey",
                            "type": "bytes32"
                        }
                    ],
                    "name": "getCallGracePeriod",
                    "outputs": [
                        {
                            "name": "",
                            "type": "uint256"
                        }
                    ],
                    "type": "function"
                },
                {
                    "constant": false,
                    "inputs": [
                        {
                            "name": "schedulerAddress",
                            "type": "address"
                        }
                    ],
                    "name": "addAuthorization",
                    "outputs": [],
                    "type": "function"
                },
                {
                    "constant": true,
                    "inputs": [],
                    "name": "getLastCallKey",
                    "outputs": [
                        {
                            "name": "",
                            "type": "bytes32"
                        }
                    ],
                    "type": "function"
                },
                {
                    "constant": false,
                    "inputs": [
                        {
                            "name": "contractAddress",
                            "type": "address"
                        },
                        {
                            "name": "abiSignature",
                            "type": "bytes4"
                        },
                        {
                            "name": "dataHash",
                            "type": "bytes32"
                        },
                        {
                            "name": "targetBlock",
                            "type": "uint256"
                        },
                        {
                            "name": "gracePeriod",
                            "type": "uint8"
                        },
                        {
                            "name": "nonce",
                            "type": "uint256"
                        }
                    ],
                    "name": "scheduleCall",
                    "outputs": [],
                    "type": "function"
                },
                {
                    "constant": true,
                    "inputs": [
                        {
                            "name": "scheduledBy",
                            "type": "address"
                        },
                        {
                            "name": "contractAddress",
                            "type": "address"
                        },
                        {
                            "name": "abiSignature",
                            "type": "bytes4"
                        },
                        {
                            "name": "dataHash",
                            "type": "bytes32"
                        },
                        {
                            "name": "targetBlock",
                            "type": "uint256"
                        },
                        {
                            "name": "gracePeriod",
                            "type": "uint8"
                        },
                        {
                            "name": "nonce",
                            "type": "uint256"
                        }
                    ],
                    "name": "getCallKey",
                    "outputs": [
                        {
                            "name": "",
                            "type": "bytes32"
                        }
                    ],
                    "type": "function"
                },
                {
                    "constant": true,
                    "inputs": [],
                    "name": "authorizedAddress",
                    "outputs": [
                        {
                            "name": "",
                            "type": "address"
                        }
                    ],
                    "type": "function"
                },
                {
                    "constant": false,
                    "inputs": [
                        {
                            "name": "callKey",
                            "type": "bytes32"
                        }
                    ],
                    "name": "cancelCall",
                    "outputs": [],
                    "type": "function"
                },
                {
                    "constant": true,
                    "inputs": [],
                    "name": "getCallerPoolAddress",
                    "outputs": [
                        {
                            "name": "",
                            "type": "address"
                        }
                    ],
                    "type": "function"
                },
                {
                    "constant": true,
                    "inputs": [
                        {
                            "name": "schedulerAddress",
                            "type": "address"
                        },
                        {
                            "name": "contractAddress",
                            "type": "address"
                        }
                    ],
                    "name": "checkAuthorization",
                    "outputs": [
                        {
                            "name": "",
                            "type": "bool"
                        }
                    ],
                    "type": "function"
                },
                {
                    "constant": true,
                    "inputs": [
                        {
                            "name": "",
                            "type": "address"
                        }
                    ],
                    "name": "accountBalances",
                    "outputs": [
                        {
                            "name": "",
                            "type": "uint256"
                        }
                    ],
                    "type": "function"
                },
                {
                    "constant": true,
                    "inputs": [
                        {
                            "name": "callKey",
                            "type": "bytes32"
                        }
                    ],
                    "name": "checkIfSuccess",
                    "outputs": [
                        {
                            "name": "",
                            "type": "bool"
                        }
                    ],
                    "type": "function"
                },
                {
                    "constant": true,
                    "inputs": [
                        {
                            "name": "callKey",
                            "type": "bytes32"
                        }
                    ],
                    "name": "getCallData",
                    "outputs": [
                        {
                            "name": "",
                            "type": "bytes"
                        }
                    ],
                    "type": "function"
                },
                {
                    "constant": true,
                    "inputs": [
                        {
                            "name": "callKey",
                            "type": "bytes32"
                        }
                    ],
                    "name": "getCallBaseGasPrice",
                    "outputs": [
                        {
                            "name": "",
                            "type": "uint256"
                        }
                    ],
                    "type": "function"
                },
                {
                    "constant": true,
                    "inputs": [
                        {
                            "name": "callKey",
                            "type": "bytes32"
                        }
                    ],
                    "name": "getCallGasPrice",
                    "outputs": [
                        {
                            "name": "",
                            "type": "uint256"
                        }
                    ],
                    "type": "function"
                },
                {
                    "constant": true,
                    "inputs": [
                        {
                            "name": "callKey",
                            "type": "bytes32"
                        }
                    ],
                    "name": "getCallScheduledBy",
                    "outputs": [
                        {
                            "name": "",
                            "type": "address"
                        }
                    ],
                    "type": "function"
                },
                {
                    "constant": true,
                    "inputs": [],
                    "name": "unauthorizedAddress",
                    "outputs": [
                        {
                            "name": "",
                            "type": "address"
                        }
                    ],
                    "type": "function"
                },
                {
                    "constant": false,
                    "inputs": [
                        {
                            "name": "schedulerAddress",
                            "type": "address"
                        }
                    ],
                    "name": "removeAuthorization",
                    "outputs": [],
                    "type": "function"
                },
                {
                    "constant": true,
                    "inputs": [],
                    "name": "getGroveAddress",
                    "outputs": [
                        {
                            "name": "",
                            "type": "address"
                        }
                    ],
                    "type": "function"
                },
                {
                    "constant": true,
                    "inputs": [
                        {
                            "name": "callKey",
                            "type": "bytes32"
                        }
                    ],
                    "name": "getCallPayout",
                    "outputs": [
                        {
                            "name": "",
                            "type": "uint256"
                        }
                    ],
                    "type": "function"
                },
                {
                    "constant": true,
                    "inputs": [
                        {
                            "name": "callKey",
                            "type": "bytes32"
                        }
                    ],
                    "name": "checkIfCancelled",
                    "outputs": [
                        {
                            "name": "",
                            "type": "bool"
                        }
                    ],
                    "type": "function"
                },
                {
                    "constant": true,
                    "inputs": [],
                    "name": "getLastData",
                    "outputs": [
                        {
                            "name": "",
                            "type": "bytes"
                        }
                    ],
                    "type": "function"
                },
                {
                    "constant": false,
                    "inputs": [],
                    "name": "registerData",
                    "outputs": [],
                    "type": "function"
                },
                {
                    "constant": true,
                    "inputs": [
                        {
                            "name": "callKey",
                            "type": "bytes32"
                        }
                    ],
                    "name": "getCallABISignature",
                    "outputs": [
                        {
                            "name": "",
                            "type": "bytes4"
                        }
                    ],
                    "type": "function"
                },
                {
                    "constant": true,
                    "inputs": [
                        {
                            "name": "baseGasPrice",
                            "type": "uint256"
                        },
                        {
                            "name": "gasPrice",
                            "type": "uint256"
                        }
                    ],
                    "name": "getCallFeeScalar",
                    "outputs": [
                        {
                            "name": "",
                            "type": "uint256"
                        }
                    ],
                    "type": "function"
                },
                {
                    "constant": true,
                    "inputs": [],
                    "name": "getGroveIndexName",
                    "outputs": [
                        {
                            "name": "",
                            "type": "bytes32"
                        }
                    ],
                    "type": "function"
                },
                {
                    "constant": true,
                    "inputs": [
                        {
                            "name": "callKey",
                            "type": "bytes32"
                        }
                    ],
                    "name": "getCallCalledAtBlock",
                    "outputs": [
                        {
                            "name": "",
                            "type": "uint256"
                        }
                    ],
                    "type": "function"
                },
                {
                    "constant": false,
                    "inputs": [
                        {
                            "name": "accountAddress",
                            "type": "address"
                        }
                    ],
                    "name": "deposit",
                    "outputs": [],
                    "type": "function"
                },
                {
                    "constant": false,
                    "inputs": [
                        {
                            "name": "contractAddress",
                            "type": "address"
                        },
                        {
                            "name": "abiSignature",
                            "type": "bytes4"
                        },
                        {
                            "name": "dataHash",
                            "type": "bytes32"
                        },
                        {
                            "name": "targetBlock",
                            "type": "uint256"
                        }
                    ],
                    "name": "scheduleCall",
                    "outputs": [],
                    "type": "function"
                },
                {
                    "constant": true,
                    "inputs": [
                        {
                            "name": "callKey",
                            "type": "bytes32"
                        }
                    ],
                    "name": "getCallDataHash",
                    "outputs": [
                        {
                            "name": "",
                            "type": "bytes32"
                        }
                    ],
                    "type": "function"
                },
                {
                    "constant": true,
                    "inputs": [
                        {
                            "name": "callKey",
                            "type": "bytes32"
                        }
                    ],
                    "name": "getCallFee",
                    "outputs": [
                        {
                            "name": "",
                            "type": "uint256"
                        }
                    ],
                    "type": "function"
                },
                {
                    "constant": false,
                    "inputs": [
                        {
                            "name": "callKey",
                            "type": "bytes32"
                        }
                    ],
                    "name": "doCall",
                    "outputs": [],
                    "type": "function"
                },
                {
                    "inputs": [],
                    "type": "constructor"
                },
                {
                    "anonymous": false,
                    "inputs": [
                        {
                            "indexed": true,
                            "name": "_from",
                            "type": "address"
                        },
                        {
                            "indexed": true,
                            "name": "accountAddress",
                            "type": "address"
                        },
                        {
                            "indexed": false,
                            "name": "value",
                            "type": "uint256"
                        }
                    ],
                    "name": "Deposit",
                    "type": "event"
                },
                {
                    "anonymous": false,
                    "inputs": [
                        {
                            "indexed": true,
                            "name": "accountAddress",
                            "type": "address"
                        },
                        {
                            "indexed": false,
                            "name": "value",
                            "type": "uint256"
                        }
                    ],
                    "name": "Withdraw",
                    "type": "event"
                },
                {
                    "anonymous": false,
                    "inputs": [
                        {
                            "indexed": true,
                            "name": "executedBy",
                            "type": "address"
                        },
                        {
                            "indexed": true,
                            "name": "callKey",
                            "type": "bytes32"
                        }
                    ],
                    "name": "CallExecuted",
                    "type": "event"
                },
                {
                    "anonymous": false,
                    "inputs": [
                        {
                            "indexed": true,
                            "name": "executedBy",
                            "type": "address"
                        },
                        {
                            "indexed": true,
                            "name": "callKey",
                            "type": "bytes32"
                        },
                        {
                            "indexed": false,
                            "name": "reason",
                            "type": "bytes18"
                        }
                    ],
                    "name": "CallAborted",
                    "type": "event"
                },
                {
                    "anonymous": false,
                    "inputs": [
                        {
                            "indexed": true,
                            "name": "callKey",
                            "type": "bytes32"
                        }
                    ],
                    "name": "CallScheduled",
                    "type": "event"
                }
            ],
            "compilerVersion": "0.1.3-1736fe80",
            "developerDoc": {
                "methods": {}
            },
            "language": "Solidity",
            "languageVersion": "0",
            "source": "/*\n *  Version 0.3.0\n *\n *  address: 0xdb15058402c241b04a03846f6fb104b1fbeea10b\n */\ncontract Relay {\n        address operator;\n\n        function Relay() {\n                operator = msg.sender;\n        }\n\n        function relayCall(address contractAddress, bytes4 abiSignature, bytes data) public returns (bool) {\n                if (msg.sender != operator) {\n                        __throw();\n                }\n                return contractAddress.call(abiSignature, data);\n        }\n\n        function __throw() internal {\n                int[] x;\n                x[1];\n        }\n}\n\n\ncontract CallerPool {\n        address operator;\n\n        function CallerPool() {\n                operator = msg.sender;\n        }\n\n        /*\n         *  Caller bonding\n         */\n        mapping (address => uint) public callerBonds;\n\n        function getMinimumBond() constant returns (uint) {\n                return tx.gasprice * block.gaslimit;\n        }\n\n        function _deductFromBond(address callerAddress, uint value) internal {\n                /*\n                 *  deduct funds from a bond value without risk of an\n                 *  underflow.\n                 */\n                if (value > callerBonds[callerAddress]) {\n                        // Prevent Underflow.\n                        __throw();\n                }\n                callerBonds[callerAddress] -= value;\n        }\n\n        function _addToBond(address callerAddress, uint value) internal {\n                /*\n                 *  Add funds to a bond value without risk of an\n                 *  overflow.\n                 */\n                if (callerBonds[callerAddress] + value < callerBonds[callerAddress]) {\n                        // Prevent Overflow\n                        __throw();\n                }\n                callerBonds[callerAddress] += value;\n        }\n\n        function depositBond() public {\n                _addToBond(msg.sender, msg.value);\n        }\n\n        function withdrawBond(uint value) public {\n                /*\n                 *  Only if you are not in either of the current call pools.\n                 */\n                if (isInAnyPool(msg.sender)) {\n                        // Prevent underflow\n                        if (value > callerBonds[msg.sender]) {\n                                __throw();\n                        }\n                        // Don't allow withdrawl if this would drop the bond\n                        // balance below the minimum.\n                        if (callerBonds[msg.sender] - value < getMinimumBond()) {\n                                return;\n                        }\n                }\n                _deductFromBond(msg.sender, value);\n                if (!msg.sender.send(value)) {\n                        // Potentially sending money to a contract that\n                        // has a fallback function.  So instead, try\n                        // tranferring the funds with the call api.\n                        if (!msg.sender.call.gas(msg.gas).value(value)()) {\n                                // Revert the entire transaction.  No\n                                // need to destroy the funds.\n                                __throw();\n                        }\n                }\n        }\n\n        function() {\n                /*\n                 *  Fallback function that allows depositing bond funds just by\n                 *  sending a transaction.\n                 */\n                _addToBond(msg.sender, msg.value);\n        }\n\n        /*\n         *  API used by Alarm service\n         */\n        function getDesignatedCaller(bytes32 callKey, uint targetBlock, uint8 gracePeriod, uint blockNumber) constant returns (address) {\n                /*\n                 *  Returns the caller from the current call pool who is\n                 *  designated as the executor of this call.\n                 */\n                if (blockNumber < targetBlock || blockNumber > targetBlock + gracePeriod) {\n                        // blockNumber not within call window.\n                        return 0x0;\n                }\n\n                // Pool used is based on the starting block for the call.  This\n                // allows us to know that the pool cannot change for at least\n                // POOL_FREEZE_NUM_BLOCKS which is kept greater than the max\n                // grace period.\n                uint poolNumber = getPoolKeyForBlock(targetBlock);\n                if (poolNumber == 0) {\n                        // No pool currently in operation.\n                        return 0x0;\n                }\n                var pool = callerPools[poolNumber];\n\n                uint numWindows = gracePeriod / 4;\n                uint blockWindow = (blockNumber - targetBlock) / 4;\n\n                if (blockWindow + 2 > numWindows) {\n                        // We are within the free-for-all period.\n                        return 0x0;\n                }\n\n                uint offset = uint(callKey) % pool.length;\n                return pool[(offset + blockWindow) % pool.length];\n        }\n\n        event AwardedMissedBlockBonus(address indexed fromCaller, address indexed toCaller, uint indexed poolNumber, bytes32 callKey, uint blockNumber, uint bonusAmount);\n\n        function _doBondBonusTransfer(address fromCaller, address toCaller) internal returns (uint) {\n                uint bonusAmount = getMinimumBond();\n                uint bondBalance = callerBonds[fromCaller];\n\n                // If the bond balance is lower than the award\n                // balance, then adjust the reward amount to\n                // match the bond balance.\n                if (bonusAmount > bondBalance) {\n                        bonusAmount = bondBalance;\n                }\n\n                // Transfer the funds fromCaller => toCaller\n                _deductFromBond(fromCaller, bonusAmount);\n                _addToBond(toCaller, bonusAmount);\n\n                return bonusAmount;\n        }\n\n        function awardMissedBlockBonus(address toCaller, bytes32 callKey, uint targetBlock, uint8 gracePeriod) public {\n                if (msg.sender != operator) {\n                        return;\n                }\n\n                uint poolNumber = getPoolKeyForBlock(targetBlock);\n                var pool = callerPools[poolNumber];\n                uint i;\n                uint bonusAmount;\n                address fromCaller;\n\n                uint numWindows = gracePeriod / 4;\n                uint blockWindow = (block.number - targetBlock) / 4;\n\n                // Check if we are within the free-for-all period.  If so, we\n                // award from all pool members.\n                if (blockWindow + 2 > numWindows) {\n                        address firstCaller = getDesignatedCaller(callKey, targetBlock, gracePeriod, targetBlock);\n                        for (i = targetBlock; i <= targetBlock + gracePeriod; i += 4) {\n                                fromCaller = getDesignatedCaller(callKey, targetBlock, gracePeriod, i);\n                                if (fromCaller == firstCaller && i != targetBlock) {\n                                        // We have already gone through all of\n                                        // the pool callers so we should break\n                                        // out of the loop.\n                                        break;\n                                }\n                                if (fromCaller == toCaller) {\n                                        continue;\n                                }\n                                bonusAmount = _doBondBonusTransfer(fromCaller, toCaller);\n\n                                // Log the bonus was awarded.\n                                AwardedMissedBlockBonus(fromCaller, toCaller, poolNumber, callKey, block.number, bonusAmount);\n                        }\n                        return;\n                }\n\n                // Special case for single member and empty pools\n                if (pool.length < 2) {\n                        return;\n                }\n\n                // Otherwise the award comes from the previous caller.\n                for (i = 0; i < pool.length; i++) {\n                        // Find where the member is in the pool and\n                        // award from the previous pool members bond.\n                        if (pool[i] == toCaller) {\n                                fromCaller = pool[(i + pool.length - 1) % pool.length];\n\n                                bonusAmount = _doBondBonusTransfer(fromCaller, toCaller);\n\n                                // Log the bonus was awarded.\n                                AwardedMissedBlockBonus(fromCaller, toCaller, poolNumber, callKey, block.number, bonusAmount);\n\n                                // Remove the caller from the next pool.\n                                if (getNextPoolKey() == 0) {\n                                        // This is the first address to modify the\n                                        // current pool so we need to setup the next\n                                        // pool.\n                                        _initiateNextPool();\n                                }\n                                _removeFromPool(fromCaller, getNextPoolKey());\n                                return;\n                        }\n                }\n        }\n\n        /*\n         *  Caller Pool Management\n         */\n        uint[] public poolHistory;\n        mapping (uint => address[]) callerPools;\n\n        function getPoolKeyForBlock(uint blockNumber) constant returns (uint) {\n                if (poolHistory.length == 0) {\n                        return 0;\n                }\n                for (uint i = 0; i < poolHistory.length; i++) {\n                        uint poolStartBlock = poolHistory[poolHistory.length - i - 1];\n                        if (poolStartBlock <= blockNumber) {\n                                return poolStartBlock;\n                        }\n                }\n                return 0;\n        }\n\n        function getActivePoolKey() constant returns (uint) {\n                return getPoolKeyForBlock(block.number);\n        }\n\n        function getPoolSize(uint poolKey) constant returns (uint) {\n                return callerPools[poolKey].length;\n        }\n\n        function getNextPoolKey() constant returns (uint) {\n                if (poolHistory.length == 0) {\n                        return 0;\n                }\n                uint latestPool = poolHistory[poolHistory.length - 1];\n                if (latestPool > block.number) {\n                        return latestPool;\n                }\n                return 0;\n        }\n\n        function isInAnyPool(address callerAddress) constant returns (bool) {\n                /*\n                 *  Returns boolean whether the `callerAddress` is in either\n                 *  the current active pool or the next pool.\n                 */\n                return isInPool(msg.sender, getActivePoolKey()) || isInPool(msg.sender, getNextPoolKey());\n        }\n\n        function isInPool(address callerAddress, uint poolNumber) constant returns (bool) {\n                /*\n                 *  Returns boolean whether the `callerAddress` is in the\n                 *  poolNumber.\n                 */\n                if (poolNumber == 0 ) {\n                        // Nobody can be in pool 0\n                        return false;\n                }\n\n                var pool = callerPools[poolNumber];\n\n                // Nobody is in the pool.\n                if (pool.length == 0) {\n                        return false;\n                }\n\n                for (uint i = 0; i < pool.length; i++) {\n                        // Address is in the pool and thus is allowed to exit.\n                        if (pool[i] == callerAddress) {\n                                return true;\n                        }\n                }\n\n                return false;\n        }\n\n        // Ten minutes into the future.\n        uint constant POOL_FREEZE_NUM_BLOCKS = 256;\n\n        function getPoolFreezeDuration() constant returns (uint) {\n                return POOL_FREEZE_NUM_BLOCKS;\n        }\n\n        function getPoolMinimumLength() constant returns (uint) {\n                return 2 * POOL_FREEZE_NUM_BLOCKS;\n        }\n\n        function canEnterPool(address callerAddress) constant returns (bool) {\n                /*\n                 *  Returns boolean whether `callerAddress` is allowed to enter\n                 *  the next pool (which may or may not already have been\n                 *  created.\n                 */\n                // Not allowed to join if you are in either the current\n                // active pool or the next pool.\n                if (isInAnyPool(callerAddress)) {\n                        return false;\n                }\n\n                // Next pool begins within the POOL_FREEZE_NUM_BLOCKS grace\n                // period so no changes are allowed.\n                if (getNextPoolKey() != 0 && block.number >= (getNextPoolKey() - POOL_FREEZE_NUM_BLOCKS)) {\n                        return false;\n                }\n\n                // Account bond balance is too low.\n                if (callerBonds[callerAddress] < getMinimumBond()) {\n                        return false;\n                }\n                \n                return true;\n        }\n\n        function canExitPool(address callerAddress) constant returns (bool) {\n                /*\n                 *  Returns boolean whether `callerAddress` is allowed to exit\n                 *  the current active pool.\n                 */\n                // Can't exit if we aren't in the current active pool.\n                if (!isInPool(callerAddress, getActivePoolKey())) {\n                        return false;\n                }\n\n                // There is a next pool coming up.\n                if (getNextPoolKey() != 0) {\n                        // Next pool begins within the POOL_FREEZE_NUM_BLOCKS\n                        // window and thus can't be modified.\n                        if (block.number >= (getNextPoolKey() - POOL_FREEZE_NUM_BLOCKS)) {\n                                return false;\n                        }\n\n                        // Next pool was already setup and callerAddress isn't\n                        // in it which indicates that they already left.\n                        if (!isInPool(callerAddress, getNextPoolKey())) {\n                                return false;\n                        }\n                }\n\n                // They must be in the current pool and either the next pool\n                // hasn't been initiated or it has but this user hasn't left\n                // yet.\n                return true;\n        }\n\n        function _initiateNextPool() internal {\n                if (getNextPoolKey() != 0) {\n                        // If there is already a next pool, we shouldn't\n                        // initiate a new one until it has become active.\n                        __throw();\n                }\n                // Set the next pool to start at double the freeze block number\n                // in the future.\n                uint nextPool = block.number + 2 * POOL_FREEZE_NUM_BLOCKS;\n\n                // Copy the current pool into the next pool.\n                callerPools[nextPool] = callerPools[getActivePoolKey()];\n\n                // Randomize the pool order\n                _shufflePool(nextPool);\n\n                // Push the next pool into the pool history.\n                poolHistory.length += 1;\n                poolHistory[poolHistory.length - 1] = nextPool;\n        }\n\n        function _shufflePool(uint poolNumber) internal {\n                var pool = callerPools[poolNumber];\n\n                uint swapIndex;\n                address buffer;\n\n                for (uint i = 0; i < pool.length; i++) {\n                        swapIndex = uint(sha3(block.blockhash(block.number), i)) % pool.length;\n                        if (swapIndex == i) {\n                                continue;\n                        }\n                        buffer = pool[i];\n                        pool[i] = pool[swapIndex];\n                        pool[swapIndex] = buffer;\n                }\n        }\n\n        event AddedToPool(address indexed callerAddress, uint indexed pool);\n        event RemovedFromPool(address indexed callerAddress, uint indexed pool);\n\n        function _addToPool(address callerAddress, uint poolNumber) internal {\n                if (poolNumber == 0 ) {\n                        // This shouldn't be called with 0;\n                        __throw();\n                }\n\n                // already in the pool.\n                if (isInPool(callerAddress, poolNumber)) {\n                        return;\n                }\n                var pool = callerPools[poolNumber];\n                pool.length += 1;\n                pool[pool.length - 1] = callerAddress;\n                \n                // Log the addition.\n                AddedToPool(callerAddress, poolNumber);\n        }\n\n        function _removeFromPool(address callerAddress, uint poolNumber) internal {\n                if (poolNumber == 0 ) {\n                        // This shouldn't be called with 0;\n                        __throw();\n                }\n\n                // nothing to remove.\n                if (!isInPool(callerAddress, poolNumber)) {\n                        return;\n                }\n                var pool = callerPools[poolNumber];\n                // special case length == 1\n                if (pool.length == 1) {\n                        pool.length = 0;\n                }\n                for (uint i = 0; i < pool.length; i++) {\n                        // When we find the index of the address to remove we\n                        // shift the last person to that location and then we\n                        // truncate the last member off of the end.\n                        if (pool[i] == callerAddress) {\n                                pool[i] = pool[pool.length - 1];\n                                pool.length -= 1;\n                                break;\n                        }\n                }\n\n                // Log the addition.\n                RemovedFromPool(callerAddress, poolNumber);\n        }\n\n        function enterPool() public {\n                /*\n                 *  Request to be added to the call pool.\n                 */\n                if (canEnterPool(msg.sender)) {\n                        if (getNextPoolKey() == 0) {\n                                // This is the first address to modify the\n                                // current pool so we need to setup the next\n                                // pool.\n                                _initiateNextPool();\n                        }\n                        _addToPool(msg.sender, getNextPoolKey());\n                }\n        }\n\n        function exitPool() public {\n                /*\n                 *  Request to be removed from the call pool.\n                 */\n                if (canExitPool(msg.sender)) {\n                        if (getNextPoolKey() == 0) {\n                                // This is the first address to modify the\n                                // current pool so we need to setup the next\n                                // pool.\n                                _initiateNextPool();\n                        }\n                        _removeFromPool(msg.sender, getNextPoolKey());\n                }\n        }\n\n        function __throw() internal {\n                int[] x;\n                x[1];\n        }\n}\n\n\ncontract GroveAPI {\n        function getIndexId(address ownerAddress, bytes32 indexName) constant returns (bytes32);\n        function insert(bytes32 indexName, bytes32 id, int value) public;\n}\n\n\ncontract Alarm {\n        /*\n         *  Administration API\n         *\n         *  There is currently no special administrative API beyond the hard\n         *  coded owner address which receives 1% of each executed call.  This\n         *  eliminates any need for trust as nobody has any special access.\n         */\n        function Alarm() {\n                unauthorizedRelay = new Relay();\n                authorizedRelay = new Relay();\n                callerPool = new CallerPool();\n        }\n\n        address constant owner = 0xd3cda913deb6f67967b99d67acdfa1712c293601;\n\n        // The deployed grove contract for call tree tracking.\n        GroveAPI grove = GroveAPI(0xfe9d4e5717ec0e16f8301240df5c3f7d3e9effef);\n\n        /*\n         *  Account Management API\n         */\n        mapping (address => uint) public accountBalances;\n\n        function _deductFunds(address accountAddress, uint value) internal {\n                /*\n                 *  Helper function that should be used for any reduction of\n                 *  account funds.  It has error checking to prevent\n                 *  underflowing the account balance which would be REALLY bad.\n                 */\n                if (value > accountBalances[accountAddress]) {\n                        // Prevent Underflow.\n                        __throw();\n                }\n                accountBalances[accountAddress] -= value;\n        }\n\n        function _addFunds(address accountAddress, uint value) internal {\n                /*\n                 *  Helper function that should be used for any addition of\n                 *  account funds.  It has error checking to prevent\n                 *  overflowing the account balance.\n                 */\n                if (accountBalances[accountAddress] + value < accountBalances[accountAddress]) {\n                        // Prevent Overflow.\n                        __throw();\n                }\n                accountBalances[accountAddress] += value;\n        }\n\n        event Deposit(address indexed _from, address indexed accountAddress, uint value);\n\n        function deposit(address accountAddress) public {\n                /*\n                 *  Public API for depositing funds in a specified account.\n                 */\n                _addFunds(accountAddress, msg.value);\n                Deposit(msg.sender, accountAddress, msg.value);\n        }\n\n        event Withdraw(address indexed accountAddress, uint value);\n\n        function withdraw(uint value) public {\n                /*\n                 *  Public API for withdrawing funds.\n                 */\n                if (accountBalances[msg.sender] >= value) {\n                        _deductFunds(msg.sender, value);\n                        if (!msg.sender.send(value)) {\n                                // Potentially sending money to a contract that\n                                // has a fallback function.  So instead, try\n                                // tranferring the funds with the call api.\n                                if (!msg.sender.call.gas(msg.gas).value(value)()) {\n                                        // Revert the entire transaction.  No\n                                        // need to destroy the funds.\n                                        __throw();\n                                }\n                        }\n                        Withdraw(msg.sender, value);\n                }\n        }\n\n        function() {\n                /*\n                 *  Fallback function that allows depositing funds just by\n                 *  sending a transaction.\n                 */\n                _addFunds(msg.sender, msg.value);\n                Deposit(msg.sender, msg.sender, msg.value);\n        }\n\n        /*\n         *  Scheduling Authorization API\n         */\n        Relay unauthorizedRelay;\n        Relay authorizedRelay;\n\n        function unauthorizedAddress() constant returns (address) {\n                return address(unauthorizedRelay);\n        }\n\n        function authorizedAddress() constant returns (address) {\n                return address(authorizedRelay);\n        }\n\n        mapping (bytes32 => bool) accountAuthorizations;\n\n        function addAuthorization(address schedulerAddress) public {\n                accountAuthorizations[sha3(schedulerAddress, msg.sender)] = true;\n        }\n\n        function removeAuthorization(address schedulerAddress) public {\n                accountAuthorizations[sha3(schedulerAddress, msg.sender)] = false;\n        }\n\n        function checkAuthorization(address schedulerAddress, address contractAddress) constant returns (bool) {\n                return accountAuthorizations[sha3(schedulerAddress, contractAddress)];\n        }\n\n        /*\n         *  Call Information API\n         */\n        bytes32 lastCallKey;\n\n        function getLastCallKey() constant returns (bytes32) {\n                return lastCallKey;\n        }\n\n        struct Call {\n                address contractAddress;\n                address scheduledBy;\n                uint calledAtBlock;\n                uint targetBlock;\n                uint8 gracePeriod;\n                uint nonce;\n                uint baseGasPrice;\n                uint gasPrice;\n                uint gasUsed;\n                uint gasCost;\n                uint payout;\n                uint fee;\n                address executedBy;\n                bytes4 abiSignature;\n                bool isCancelled;\n                bool wasCalled;\n                bool wasSuccessful;\n                bytes32 dataHash;\n        }\n\n        mapping (bytes32 => Call) key_to_calls;\n\n        /*\n         *  Getter methods for `Call` information\n         */\n        function getCallContractAddress(bytes32 callKey) constant returns (address) {\n                return key_to_calls[callKey].contractAddress;\n        }\n\n        function getCallScheduledBy(bytes32 callKey) constant returns (address) {\n                return key_to_calls[callKey].scheduledBy;\n        }\n\n        function getCallCalledAtBlock(bytes32 callKey) constant returns (uint) {\n                return key_to_calls[callKey].calledAtBlock;\n        }\n\n        function getCallGracePeriod(bytes32 callKey) constant returns (uint) {\n                return key_to_calls[callKey].gracePeriod;\n        }\n\n        function getCallTargetBlock(bytes32 callKey) constant returns (uint) {\n                return key_to_calls[callKey].targetBlock;\n        }\n\n        function getCallBaseGasPrice(bytes32 callKey) constant returns (uint) {\n                return key_to_calls[callKey].baseGasPrice;\n        }\n\n        function getCallGasPrice(bytes32 callKey) constant returns (uint) {\n                return key_to_calls[callKey].gasPrice;\n        }\n\n        function getCallGasUsed(bytes32 callKey) constant returns (uint) {\n                return key_to_calls[callKey].gasUsed;\n        }\n\n        function getCallABISignature(bytes32 callKey) constant returns (bytes4) {\n                return key_to_calls[callKey].abiSignature;\n        }\n\n        function checkIfCalled(bytes32 callKey) constant returns (bool) {\n                return key_to_calls[callKey].wasCalled;\n        }\n\n        function checkIfSuccess(bytes32 callKey) constant returns (bool) {\n                return key_to_calls[callKey].wasSuccessful;\n        }\n\n        function checkIfCancelled(bytes32 callKey) constant returns (bool) {\n                return key_to_calls[callKey].isCancelled;\n        }\n\n        function getCallDataHash(bytes32 callKey) constant returns (bytes32) {\n                return key_to_calls[callKey].dataHash;\n        }\n\n        function getCallPayout(bytes32 callKey) constant returns (uint) {\n                return key_to_calls[callKey].payout;\n        }\n\n        function getCallFee(bytes32 callKey) constant returns (uint) {\n                return key_to_calls[callKey].fee;\n        }\n\n        /*\n         *  Data Registry API\n         */\n        bytes lastData;\n        uint lastDataLength;\n        bytes32 lastDataHash;\n\n        function getLastDataHash() constant returns (bytes32) {\n                return lastDataHash;\n        }\n\n        function getLastDataLength() constant returns (uint) {\n                return lastDataLength;\n        }\n\n        function getLastData() constant returns (bytes) {\n                return lastData;\n        }\n\n        function getCallData(bytes32 callKey) constant returns (bytes) {\n                return hash_to_data[key_to_calls[callKey].dataHash];\n        }\n\n        mapping (bytes32 => bytes) hash_to_data;\n\n        /*\n         *  Data registration API\n         */\n        //event DataRegistered(bytes32 indexed dataHash);\n\n        function registerData() public {\n                lastData.length = msg.data.length - 4;\n                if (msg.data.length > 4) {\n                        for (uint i = 0; i < lastData.length; i++) {\n                                lastData[i] = msg.data[i + 4];\n                        }\n                }\n                hash_to_data[sha3(lastData)] = lastData;\n                lastDataHash = sha3(lastData);\n                lastDataLength = lastData.length;\n                lastData = lastData;\n\n                // Log it.\n                //DataRegistered(lastDataHash);\n        }\n\n        /*\n         *  Call execution API\n         */\n        CallerPool callerPool;\n\n        function getCallerPoolAddress() constant returns (address) {\n                return address(callerPool);\n        }\n\n        // This number represents the constant gas cost of the addition\n        // operations that occur in `doCall` that cannot be tracked with\n        // msg.gas.\n        uint constant EXTRA_CALL_GAS = 151098;\n\n        // This number represents the overall overhead involved in executing a\n        // scheduled call.\n        uint constant CALL_OVERHEAD = 144982;\n\n        event CallExecuted(address indexed executedBy, bytes32 indexed callKey);\n        event CallAborted(address indexed executedBy, bytes32 indexed callKey, bytes18 reason);\n\n        function doCall(bytes32 callKey) public {\n                uint gasBefore = msg.gas;\n\n                var call = key_to_calls[callKey];\n\n                if (call.wasCalled) {\n                        // The call has already been executed so don't do it again.\n                        CallAborted(msg.sender, callKey, \"ALREADY CALLED\");\n                        return;\n                }\n\n                if (call.isCancelled) {\n                        // The call was cancelled so don't execute it.\n                        CallAborted(msg.sender, callKey, \"CANCELLED\");\n                        return;\n                }\n\n                if (call.contractAddress == 0x0) {\n                        // This call key doesnt map to a registered call.\n                        CallAborted(msg.sender, callKey, \"UNKNOWN\");\n                        return;\n                }\n\n                if (block.number < call.targetBlock) {\n                        // Target block hasnt happened yet.\n                        CallAborted(msg.sender, callKey, \"TOO EARLY\");\n                        return;\n                }\n\n                if (block.number > call.targetBlock + call.gracePeriod) {\n                        // The blockchain has advanced passed the period where\n                        // it was allowed to be called.\n                        CallAborted(msg.sender, callKey, \"TOO LATE\");\n                        return;\n                }\n\n                uint heldBalance = getCallMaxCost(callKey);\n\n                if (accountBalances[call.scheduledBy] < heldBalance) {\n                        // The scheduledBy's account balance is less than the\n                        // current gasLimit and thus potentiall can't pay for\n                        // the call.\n\n                        // Mark it as called since it was.\n                        call.wasCalled = true;\n                        \n                        // Log it.\n                        CallAborted(msg.sender, callKey, \"INSUFFICIENT_FUNDS\");\n                        return;\n                }\n\n                // Check if this caller is allowed to execute the call.\n                if (callerPool.getPoolSize(callerPool.getActivePoolKey()) > 0) {\n                        address poolCaller = callerPool.getDesignatedCaller(callKey, call.targetBlock, call.gracePeriod, block.number);\n                        if (poolCaller != 0x0 && poolCaller != msg.sender) {\n                                // This call was reserved for someone from the\n                                // bonded pool of callers and can only be\n                                // called by them during this block window.\n                                CallAborted(msg.sender, callKey, \"WRONG_CALLER\");\n                                return;\n                        }\n\n                        uint blockWindow = (block.number - call.targetBlock) / 4;\n                        if (blockWindow > 0) {\n                                // Someone missed their call so this caller\n                                // gets to claim their bond for picking up\n                                // their slack.\n                                callerPool.awardMissedBlockBonus(msg.sender, callKey, call.targetBlock, call.gracePeriod);\n                        }\n                }\n\n                // Log metadata about the call.\n                call.gasPrice = tx.gasprice;\n                call.executedBy = msg.sender;\n                call.calledAtBlock = block.number;\n\n                // Fetch the call data\n                var data = getCallData(callKey);\n\n                // During the call, we need to put enough funds to pay for the\n                // call on hold to ensure they are available to pay the caller.\n                _deductFunds(call.scheduledBy, heldBalance);\n\n                // Mark whether the function call was successful.\n                if (checkAuthorization(call.scheduledBy, call.contractAddress)) {\n                        call.wasSuccessful = authorizedRelay.relayCall.gas(msg.gas - CALL_OVERHEAD)(call.contractAddress, call.abiSignature, data);\n                }\n                else {\n                        call.wasSuccessful = unauthorizedRelay.relayCall.gas(msg.gas - CALL_OVERHEAD)(call.contractAddress, call.abiSignature, data);\n                }\n\n                // Add the held funds back into the scheduler's account.\n                _addFunds(call.scheduledBy, heldBalance);\n\n                // Mark the call as having been executed.\n                call.wasCalled = true;\n\n                // Log the call execution.\n                CallExecuted(msg.sender, callKey);\n\n                // Compute the scalar (0 - 200) for the fee.\n                uint feeScalar = getCallFeeScalar(call.baseGasPrice, call.gasPrice);\n\n                // Log how much gas this call used.  EXTRA_CALL_GAS is a fixed\n                // amount that represents the gas usage of the commands that\n                // happen after this line.\n                call.gasUsed = (gasBefore - msg.gas + EXTRA_CALL_GAS);\n                call.gasCost = call.gasUsed * call.gasPrice;\n\n                // Now we need to pay the caller as well as keep fee.\n                // callerPayout -> call cost + 1%\n                // fee -> 1% of callerPayout\n                call.payout = call.gasCost * feeScalar * 101 / 10000;\n                call.fee = call.gasCost * feeScalar / 10000;\n\n                _deductFunds(call.scheduledBy, call.payout + call.fee);\n\n                _addFunds(msg.sender, call.payout);\n                _addFunds(owner, call.fee);\n        }\n\n        function getCallMaxCost(bytes32 callKey) constant returns (uint) {\n                /*\n                 *  tx.gasprice * block.gaslimit\n                 *  \n                 */\n                // call cost + 2%\n                var call = key_to_calls[callKey];\n\n                uint gasCost = tx.gasprice * block.gaslimit;\n                uint feeScalar = getCallFeeScalar(call.baseGasPrice, tx.gasprice);\n\n                return gasCost * feeScalar * 102 / 10000;\n        }\n\n        function getCallFeeScalar(uint baseGasPrice, uint gasPrice) constant returns (uint) {\n                /*\n                 *  Return a number between 0 - 200 to scale the fee based on\n                 *  the gas price set for the calling transaction as compared\n                 *  to the gas price of the scheduling transaction.\n                 *\n                 *  - number approaches zero as the transaction gas price goes\n                 *  above the gas price recorded when the call was scheduled.\n                 *\n                 *  - the number approaches 200 as the transaction gas price\n                 *  drops under the price recorded when the call was scheduled.\n                 *\n                 *  This encourages lower gas costs as the lower the gas price\n                 *  for the executing transaction, the higher the payout to the\n                 *  caller.\n                 */\n                if (gasPrice > baseGasPrice) {\n                        return 100 * baseGasPrice / gasPrice;\n                }\n                else {\n                        return 200 - 100 * baseGasPrice / (2 * baseGasPrice - gasPrice);\n                }\n        }\n\n        /*\n         *  Call Scheduling API\n         */\n\n        // The result of `sha()` so that we can validate that people aren't\n        // looking up call data that failed to register.\n        bytes32 constant emptyDataHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n\n        function getCallKey(address scheduledBy, address contractAddress, bytes4 abiSignature, bytes32 dataHash, uint targetBlock, uint8 gracePeriod, uint nonce) constant returns (bytes32) {\n                return sha3(scheduledBy, contractAddress, abiSignature, dataHash, targetBlock, gracePeriod, nonce);\n        }\n\n        // Ten minutes into the future.\n        uint constant MAX_BLOCKS_IN_FUTURE = 40;\n\n        event CallScheduled(bytes32 indexed callKey);\n        //event CallRejected(bytes32 indexed callKey, bytes15 reason);\n\n        function scheduleCall(address contractAddress, bytes4 abiSignature, bytes32 dataHash, uint targetBlock) public {\n                /*\n                 *  Schedule call with gracePeriod defaulted to 255 and nonce\n                 *  defaulted to 0.\n                 */\n                scheduleCall(contractAddress, abiSignature, dataHash, targetBlock, 255, 0);\n        }\n\n        function scheduleCall(address contractAddress, bytes4 abiSignature, bytes32 dataHash, uint targetBlock, uint8 gracePeriod) public {\n                /*\n                 *  Schedule call with nonce defaulted to 0.\n                 */\n                scheduleCall(contractAddress, abiSignature, dataHash, targetBlock, gracePeriod, 0);\n        }\n\n        function scheduleCall(address contractAddress, bytes4 abiSignature, bytes32 dataHash, uint targetBlock, uint8 gracePeriod, uint nonce) public {\n                /*\n                 * Primary API for scheduling a call.  Prior to calling this\n                 * the data should already have been registered through the\n                 * `registerData` API.\n                 */\n                bytes32 callKey = getCallKey(msg.sender, contractAddress, abiSignature, dataHash, targetBlock, gracePeriod, nonce);\n\n                if (dataHash != emptyDataHash && hash_to_data[dataHash].length == 0) {\n                        // Don't allow registering calls if the data hash has\n                        // not actually been registered.  The only exception is\n                        // the *emptyDataHash*.\n                        //CallRejected(callKey, \"NO_DATA\");\n                        return;\n                }\n\n                if (targetBlock < block.number + MAX_BLOCKS_IN_FUTURE) {\n                        // Don't allow scheduling further than\n                        // MAX_BLOCKS_IN_FUTURE\n                        //CallRejected(callKey, \"TOO_SOON\");\n                        return;\n                }\n                var call = key_to_calls[callKey];\n\n                if (call.contractAddress != 0x0) {\n                        //CallRejected(callKey, \"DUPLICATE\");\n                        return;\n                }\n\n                if (gracePeriod < 16) {\n                        //CallRejected(callKey, \"GRACE_TOO_SHORT\");\n                        return;\n                }\n\n                lastCallKey = callKey;\n\n                call.contractAddress = contractAddress;\n                call.scheduledBy = msg.sender;\n                call.nonce = nonce;\n                call.abiSignature = abiSignature;\n                call.dataHash = dataHash;\n                call.targetBlock = targetBlock;\n                call.gracePeriod = gracePeriod;\n                call.baseGasPrice = tx.gasprice;\n\n                // Put the call into the grove index.\n                grove.insert(GROVE_INDEX_NAME, lastCallKey, int(call.targetBlock));\n\n                CallScheduled(lastCallKey);\n        }\n\n        bytes32 constant GROVE_INDEX_NAME = \"callTargetBlock\";\n\n        function getGroveAddress() constant returns (address) {\n                return address(grove);\n        }\n\n        function getGroveIndexName() constant returns (bytes32) {\n                return GROVE_INDEX_NAME;\n        }\n\n        function getGroveIndexId() constant returns (bytes32) {\n                return grove.getIndexId(address(this), GROVE_INDEX_NAME);\n        }\n\n        //event CallCancelled(bytes32 indexed callKey);\n\n        // Two minutes\n        uint constant MIN_CANCEL_WINDOW = 8;\n\n        function cancelCall(bytes32 callKey) public {\n                var call = key_to_calls[callKey];\n                if (call.scheduledBy != msg.sender) {\n                        // Nobody but the scheduler can cancel a call.\n                        return;\n                }\n                if (call.wasCalled) {\n                        // No need to cancel a call that already was executed.\n                        return;\n                }\n                if (call.targetBlock - MIN_CANCEL_WINDOW <= block.number) {\n                        // Call cannot be cancelled this close to execution.\n                        return;\n                }\n                call.isCancelled = true;\n                //CallCancelled(callKey);\n        }\n\n        function __throw() internal {\n                int[] x;\n                x[1];\n        }\n}\n",
            "userDoc": {
                "methods": {}
            }
        }
    },
    "CallerPool": {
        "code": "0x606060405260008054600160a060020a03191633179055610e8a806100246000396000f3606060405236156100e55760e060020a600035046319f74e1f811461012957806323306ed614610147578063299179541461015257806350a3bd391461015e5780635ae348681461016a5780636595f73a14610175578063741b3c391461019057806384c92c9a146101985780638dd5e298146101ad578063910789c4146101bf5780639d12f0f5146101fc578063a6814e8e14610250578063aec918c71461025f578063b010d94a1461027f578063bc966ddc14610294578063c3daab961461029f578063c4afc3fb146102ae578063c861cd66146102c9578063e8543d0d146102e1575b6103265b61032833345b600160a060020a0382166000908152600160205260409020548082011015610359576103595b600080600181548110156100025750508052565b61032a6004356024355b60006000600083600014156108225761081a565b61032a5b3a45025b90565b61032661099333610286565b610326610957336101b4565b61032a61020061014f565b61032a6004356000818152600360205260409020545b919050565b6103266100e9565b61032a6004355b60006107f733610809610254565b61032a6004355b60006108928261019f565b61032a60043560028054829081101561000257506000527f405787fa12a823e0f2b7631cc41b3ba8828b3321ca811111fa75cd3aa3bb5ace015481565b61032660043560243560443560643560006000600060006000600060006000600060009054906101000a9004600160a060020a0316600160a060020a031633600160a060020a03161415156104de57610576565b61032a5b600061079b43610266565b61032a6004355b600060006000600260005054600014156107335761072c565b61032a6004355b600061090682610809610254565b61032a61010061014f565b61032660043561037b3361019f565b61032a5b60006000600260005054600014156107ab576107a7565b61032a60043560016020526000908152604090205481565b61033c6004356024356044356064355b6000600060006000600060008887108061030f57508760ff16890187115b1561045657600095505b5050505050949350505050565b005b565b60408051918252519081900360200190f35b60408051600160a060020a03929092168252519081900360200190f35b600160a060020a03821660009081526001602052604090208054820190555050565b156103d657600160a060020a0333166000908152600160205260409020548111156103a8576103a8610115565b6103b061014b565b600160a060020a03331660009081526001602052604090205482900310156103d6575b50565b61040433825b600160a060020a0382166000908152600160205260409020548111156109bc576109bc610115565b604051600160a060020a03331690600090839082818181858883f1935050505015156103d35733600160a060020a03165a60405183906000818181858888f1935050505015156103d3576103d3610115565b61045f89610266565b945084600014156104735760009550610319565b60008581526003602052604090209350600460ff89811682900416935089880304915060028201839011156104ab5760009550610319565b508254808a069084908284018190069081101561000257600091825260209091200154600160a060020a03169550610319565b6104e78a610266565b60008181526003602052604090209098509650600460ff8a8116829004169350438b90030491506002820183901115610526576105358b8b8b8d6102f1565b60028754101561061857610576565b8a965090505b60ff89168a018611610576576105538b8b8b896102f1565b9350600160a060020a038481169082161480156105705750898614155b156105e5575b505050505050505050505050565b604080518d815243602082015280820183905290519196508991600160a060020a038f811692908816917f47d4e871a02baa58fd74fe0787c713589a0ce351d4c70ffe2d0f10353fab9fe59181900360600190a45b6004959095019461053b565b8b600160a060020a031684600160a060020a03161415610604576105d9565b610584848d5b6000600060006109df61014b565b600095505b8654861015610576578b600160a060020a03168787815481101561000257600091825260209091200154600160a060020a0316141561068857868754600189548901030681548110156100025760206000200154600160a060020a031694506106949050848d61060a565b6001959095019461061d565b604080518d815243602082015280820183905290519196508991600160a060020a038f811692908816917f47d4e871a02baa58fd74fe0787c713589a0ce351d4c70ffe2d0f10353fab9fe59181900360600190a46106f06102b2565b60001415610706576107065b6000610a256102b2565b610576846107126102b2565b600060008260001415610cab57610cab610115565b600092505b5050919050565b600091505b60025482101561072757600280548381036000190190811015610002576000919091527f405787fa12a823e0f2b7631cc41b3ba8828b3321ca811111fa75cd3aa3bb5ace0154905083811161078f5780925061072c565b60019190910190610738565b905061014f565b600091505b5090565b60028054600019810190811015610002576000919091527f405787fa12a823e0f2b7631cc41b3ba8828b3321ca811111fa75cd3aa3bb5ace01549050438111156107a2578091506107a7565b8061080e575061080e336108096102b2565b610133565b905061018b565b600092505b505092915050565b600084815260036020526040812080549093501415610844576000925061081a565b5060005b81548110156108155784600160a060020a03168282815481101561000257600091825260209091200154600160a060020a0316141561088a576001925061081a565b600101610848565b1561089f5750600061018b565b6108a76102b2565b6000141580156108c257506101006108bd6102b2565b034310155b156108cf5750600061018b565b6108d761014b565b600160a060020a03831660009081526001602052604090205410156108fe5750600061018b565b50600161018b565b15156109145750600061018b565b61091c6102b2565b6000146108fe5761010061092e6102b2565b03431061093d5750600061018b565b610949826108096102b2565b15156108fe5750600061018b565b15610328576109646102b2565b60001415610974576109746106fc565b610328336109806102b2565b60008160001415610c1657610c16610115565b15610328576109a06102b2565b600014156109b0576109b06106fc565b610328336107126102b2565b600160a060020a0382166000908152600160205260409020805482900390555050565b600160a060020a038616600090815260016020526040902054909250905080821115610a09579050805b610a1385836103dc565b610a1d84836100ef565b81925061081a565b600014610a3457610a34610115565b50610200430160036000610a46610254565b81526020818101929092526040908101600090812084825260038452918120825481548183558284529490922090938101928215610aa55760005260206000209182015b82811115610aa5578254825591600101919060010190610a8a565b50610acb9291505b808211156107a7578054600160a060020a0319168155600101610aad565b5050610b188160008181526003602052604081209080805b8354811015610dd2578354604080514340815260208101849052815190819003909101902006925082811415610dd957610e82565b6002805460018101808355919082908015829011610b5957818360005260206000209182019101610b5991905b808211156107a75760008155600101610b45565b505060028054849350909150600019810190811015610002575080546000919091527f405787fa12a823e0f2b7631cc41b3ba8828b3321ca811111fa75cd3aa3bb5acd015550565b50505050828160018354038154811015610002575050815460008381526020812091909101600019018054600160a060020a0319169092179091556040518391600160a060020a038616917fa192e48a82f18ef1c93e722713426e5733e98d5b2858ba5c7457faf4a8297dab9190a35b505050565b610c208383610133565b15610c2a57610c11565b50600081815260036020526040902080546001810180835590829082908015829011610ba157818360005260206000209182019101610ba19190610b45565b505050505b6040518390600160a060020a038616907feee53013e70e8b24433023a137d553d5fc6a714de816654052b177b9806f35bf90600090a35b50505050565b610cb58484610133565b1515610cc057610ca5565b6000838152600360205260409020805490925060011415610d0a5760008281815481835581811511610d0557818360005260206000209182019101610d059190610b45565b505050505b5060005b8154811015610c6e5783600160a060020a03168282815481101561000257600091825260209091200154600160a060020a03161415610dca57816001835403815481101561000257906000526020600020900160009054906101000a9004600160a060020a031682828154811015610002576020600020018054600160a060020a031916909217909155508154600019810180845590839082908015829011610c6957818360005260206000209182019101610c699190610b45565b600101610d0e565b5050505050565b8381815481101561000257508054600082815260209020830154600160a060020a03169350849081101561000257906000526020600020900160009054906101000a9004600160a060020a0316848281548110156100025750602060002083018054600160a060020a03191690921790915550835482908590859081101561000257906000526020600020900160006101000a815481600160a060020a03021916908302179055505b600101610ae356",
        "info": {
            "abiDefinition": [
                {
                    "constant": true,
                    "inputs": [
                        {
                            "name": "callerAddress",
                            "type": "address"
                        },
                        {
                            "name": "poolNumber",
                            "type": "uint256"
                        }
                    ],
                    "name": "isInPool",
                    "outputs": [
                        {
                            "name": "",
                            "type": "bool"
                        }
                    ],
                    "type": "function"
                },
                {
                    "constant": true,
                    "inputs": [],
                    "name": "getMinimumBond",
                    "outputs": [
                        {
                            "name": "",
                            "type": "uint256"
                        }
                    ],
                    "type": "function"
                },
                {
                    "constant": false,
                    "inputs": [],
                    "name": "exitPool",
                    "outputs": [],
                    "type": "function"
                },
                {
                    "constant": false,
                    "inputs": [],
                    "name": "enterPool",
                    "outputs": [],
                    "type": "function"
                },
                {
                    "constant": true,
                    "inputs": [],
                    "name": "getPoolMinimumLength",
                    "outputs": [
                        {
                            "name": "",
                            "type": "uint256"
                        }
                    ],
                    "type": "function"
                },
                {
                    "constant": true,
                    "inputs": [
                        {
                            "name": "poolKey",
                            "type": "uint256"
                        }
                    ],
                    "name": "getPoolSize",
                    "outputs": [
                        {
                            "name": "",
                            "type": "uint256"
                        }
                    ],
                    "type": "function"
                },
                {
                    "constant": false,
                    "inputs": [],
                    "name": "depositBond",
                    "outputs": [],
                    "type": "function"
                },
                {
                    "constant": true,
                    "inputs": [
                        {
                            "name": "callerAddress",
                            "type": "address"
                        }
                    ],
                    "name": "isInAnyPool",
                    "outputs": [
                        {
                            "name": "",
                            "type": "bool"
                        }
                    ],
                    "type": "function"
                },
                {
                    "constant": true,
                    "inputs": [
                        {
                            "name": "callerAddress",
                            "type": "address"
                        }
                    ],
                    "name": "canEnterPool",
                    "outputs": [
                        {
                            "name": "",
                            "type": "bool"
                        }
                    ],
                    "type": "function"
                },
                {
                    "constant": true,
                    "inputs": [
                        {
                            "name": "",
                            "type": "uint256"
                        }
                    ],
                    "name": "poolHistory",
                    "outputs": [
                        {
                            "name": "",
                            "type": "uint256"
                        }
                    ],
                    "type": "function"
                },
                {
                    "constant": false,
                    "inputs": [
                        {
                            "name": "toCaller",
                            "type": "address"
                        },
                        {
                            "name": "callKey",
                            "type": "bytes32"
                        },
                        {
                            "name": "targetBlock",
                            "type": "uint256"
                        },
                        {
                            "name": "gracePeriod",
                            "type": "uint8"
                        }
                    ],
                    "name": "awardMissedBlockBonus",
                    "outputs": [],
                    "type": "function"
                },
                {
                    "constant": true,
                    "inputs": [],
                    "name": "getActivePoolKey",
                    "outputs": [
                        {
                            "name": "",
                            "type": "uint256"
                        }
                    ],
                    "type": "function"
                },
                {
                    "constant": true,
                    "inputs": [
                        {
                            "name": "blockNumber",
                            "type": "uint256"
                        }
                    ],
                    "name": "getPoolKeyForBlock",
                    "outputs": [
                        {
                            "name": "",
                            "type": "uint256"
                        }
                    ],
                    "type": "function"
                },
                {
                    "constant": true,
                    "inputs": [
                        {
                            "name": "callerAddress",
                            "type": "address"
                        }
                    ],
                    "name": "canExitPool",
                    "outputs": [
                        {
                            "name": "",
                            "type": "bool"
                        }
                    ],
                    "type": "function"
                },
                {
                    "constant": true,
                    "inputs": [],
                    "name": "getPoolFreezeDuration",
                    "outputs": [
                        {
                            "name": "",
                            "type": "uint256"
                        }
                    ],
                    "type": "function"
                },
                {
                    "constant": false,
                    "inputs": [
                        {
                            "name": "value",
                            "type": "uint256"
                        }
                    ],
                    "name": "withdrawBond",
                    "outputs": [],
                    "type": "function"
                },
                {
                    "constant": true,
                    "inputs": [],
                    "name": "getNextPoolKey",
                    "outputs": [
                        {
                            "name": "",
                            "type": "uint256"
                        }
                    ],
                    "type": "function"
                },
                {
                    "constant": true,
                    "inputs": [
                        {
                            "name": "",
                            "type": "address"
                        }
                    ],
                    "name": "callerBonds",
                    "outputs": [
                        {
                            "name": "",
                            "type": "uint256"
                        }
                    ],
                    "type": "function"
                },
                {
                    "constant": true,
                    "inputs": [
                        {
                            "name": "callKey",
                            "type": "bytes32"
                        },
                        {
                            "name": "targetBlock",
                            "type": "uint256"
                        },
                        {
                            "name": "gracePeriod",
                            "type": "uint8"
                        },
                        {
                            "name": "blockNumber",
                            "type": "uint256"
                        }
                    ],
                    "name": "getDesignatedCaller",
                    "outputs": [
                        {
                            "name": "",
                            "type": "address"
                        }
                    ],
                    "type": "function"
                },
                {
                    "inputs": [],
                    "type": "constructor"
                },
                {
                    "anonymous": false,
                    "inputs": [
                        {
                            "indexed": true,
                            "name": "fromCaller",
                            "type": "address"
                        },
                        {
                            "indexed": true,
                            "name": "toCaller",
                            "type": "address"
                        },
                        {
                            "indexed": true,
                            "name": "poolNumber",
                            "type": "uint256"
                        },
                        {
                            "indexed": false,
                            "name": "callKey",
                            "type": "bytes32"
                        },
                        {
                            "indexed": false,
                            "name": "blockNumber",
                            "type": "uint256"
                        },
                        {
                            "indexed": false,
                            "name": "bonusAmount",
                            "type": "uint256"
                        }
                    ],
                    "name": "AwardedMissedBlockBonus",
                    "type": "event"
                },
                {
                    "anonymous": false,
                    "inputs": [
                        {
                            "indexed": true,
                            "name": "callerAddress",
                            "type": "address"
                        },
                        {
                            "indexed": true,
                            "name": "pool",
                            "type": "uint256"
                        }
                    ],
                    "name": "AddedToPool",
                    "type": "event"
                },
                {
                    "anonymous": false,
                    "inputs": [
                        {
                            "indexed": true,
                            "name": "callerAddress",
                            "type": "address"
                        },
                        {
                            "indexed": true,
                            "name": "pool",
                            "type": "uint256"
                        }
                    ],
                    "name": "RemovedFromPool",
                    "type": "event"
                }
            ],
            "compilerVersion": "0.1.3-1736fe80",
            "developerDoc": {
                "methods": {}
            },
            "language": "Solidity",
            "languageVersion": "0",
            "source": "/*\n *  Version 0.3.0\n *\n *  address: 0xdb15058402c241b04a03846f6fb104b1fbeea10b\n */\ncontract Relay {\n        address operator;\n\n        function Relay() {\n                operator = msg.sender;\n        }\n\n        function relayCall(address contractAddress, bytes4 abiSignature, bytes data) public returns (bool) {\n                if (msg.sender != operator) {\n                        __throw();\n                }\n                return contractAddress.call(abiSignature, data);\n        }\n\n        function __throw() internal {\n                int[] x;\n                x[1];\n        }\n}\n\n\ncontract CallerPool {\n        address operator;\n\n        function CallerPool() {\n                operator = msg.sender;\n        }\n\n        /*\n         *  Caller bonding\n         */\n        mapping (address => uint) public callerBonds;\n\n        function getMinimumBond() constant returns (uint) {\n                return tx.gasprice * block.gaslimit;\n        }\n\n        function _deductFromBond(address callerAddress, uint value) internal {\n                /*\n                 *  deduct funds from a bond value without risk of an\n                 *  underflow.\n                 */\n                if (value > callerBonds[callerAddress]) {\n                        // Prevent Underflow.\n                        __throw();\n                }\n                callerBonds[callerAddress] -= value;\n        }\n\n        function _addToBond(address callerAddress, uint value) internal {\n                /*\n                 *  Add funds to a bond value without risk of an\n                 *  overflow.\n                 */\n                if (callerBonds[callerAddress] + value < callerBonds[callerAddress]) {\n                        // Prevent Overflow\n                        __throw();\n                }\n                callerBonds[callerAddress] += value;\n        }\n\n        function depositBond() public {\n                _addToBond(msg.sender, msg.value);\n        }\n\n        function withdrawBond(uint value) public {\n                /*\n                 *  Only if you are not in either of the current call pools.\n                 */\n                if (isInAnyPool(msg.sender)) {\n                        // Prevent underflow\n                        if (value > callerBonds[msg.sender]) {\n                                __throw();\n                        }\n                        // Don't allow withdrawl if this would drop the bond\n                        // balance below the minimum.\n                        if (callerBonds[msg.sender] - value < getMinimumBond()) {\n                                return;\n                        }\n                }\n                _deductFromBond(msg.sender, value);\n                if (!msg.sender.send(value)) {\n                        // Potentially sending money to a contract that\n                        // has a fallback function.  So instead, try\n                        // tranferring the funds with the call api.\n                        if (!msg.sender.call.gas(msg.gas).value(value)()) {\n                                // Revert the entire transaction.  No\n                                // need to destroy the funds.\n                                __throw();\n                        }\n                }\n        }\n\n        function() {\n                /*\n                 *  Fallback function that allows depositing bond funds just by\n                 *  sending a transaction.\n                 */\n                _addToBond(msg.sender, msg.value);\n        }\n\n        /*\n         *  API used by Alarm service\n         */\n        function getDesignatedCaller(bytes32 callKey, uint targetBlock, uint8 gracePeriod, uint blockNumber) constant returns (address) {\n                /*\n                 *  Returns the caller from the current call pool who is\n                 *  designated as the executor of this call.\n                 */\n                if (blockNumber < targetBlock || blockNumber > targetBlock + gracePeriod) {\n                        // blockNumber not within call window.\n                        return 0x0;\n                }\n\n                // Pool used is based on the starting block for the call.  This\n                // allows us to know that the pool cannot change for at least\n                // POOL_FREEZE_NUM_BLOCKS which is kept greater than the max\n                // grace period.\n                uint poolNumber = getPoolKeyForBlock(targetBlock);\n                if (poolNumber == 0) {\n                        // No pool currently in operation.\n                        return 0x0;\n                }\n                var pool = callerPools[poolNumber];\n\n                uint numWindows = gracePeriod / 4;\n                uint blockWindow = (blockNumber - targetBlock) / 4;\n\n                if (blockWindow + 2 > numWindows) {\n                        // We are within the free-for-all period.\n                        return 0x0;\n                }\n\n                uint offset = uint(callKey) % pool.length;\n                return pool[(offset + blockWindow) % pool.length];\n        }\n\n        event AwardedMissedBlockBonus(address indexed fromCaller, address indexed toCaller, uint indexed poolNumber, bytes32 callKey, uint blockNumber, uint bonusAmount);\n\n        function _doBondBonusTransfer(address fromCaller, address toCaller) internal returns (uint) {\n                uint bonusAmount = getMinimumBond();\n                uint bondBalance = callerBonds[fromCaller];\n\n                // If the bond balance is lower than the award\n                // balance, then adjust the reward amount to\n                // match the bond balance.\n                if (bonusAmount > bondBalance) {\n                        bonusAmount = bondBalance;\n                }\n\n                // Transfer the funds fromCaller => toCaller\n                _deductFromBond(fromCaller, bonusAmount);\n                _addToBond(toCaller, bonusAmount);\n\n                return bonusAmount;\n        }\n\n        function awardMissedBlockBonus(address toCaller, bytes32 callKey, uint targetBlock, uint8 gracePeriod) public {\n                if (msg.sender != operator) {\n                        return;\n                }\n\n                uint poolNumber = getPoolKeyForBlock(targetBlock);\n                var pool = callerPools[poolNumber];\n                uint i;\n                uint bonusAmount;\n                address fromCaller;\n\n                uint numWindows = gracePeriod / 4;\n                uint blockWindow = (block.number - targetBlock) / 4;\n\n                // Check if we are within the free-for-all period.  If so, we\n                // award from all pool members.\n                if (blockWindow + 2 > numWindows) {\n                        address firstCaller = getDesignatedCaller(callKey, targetBlock, gracePeriod, targetBlock);\n                        for (i = targetBlock; i <= targetBlock + gracePeriod; i += 4) {\n                                fromCaller = getDesignatedCaller(callKey, targetBlock, gracePeriod, i);\n                                if (fromCaller == firstCaller && i != targetBlock) {\n                                        // We have already gone through all of\n                                        // the pool callers so we should break\n                                        // out of the loop.\n                                        break;\n                                }\n                                if (fromCaller == toCaller) {\n                                        continue;\n                                }\n                                bonusAmount = _doBondBonusTransfer(fromCaller, toCaller);\n\n                                // Log the bonus was awarded.\n                                AwardedMissedBlockBonus(fromCaller, toCaller, poolNumber, callKey, block.number, bonusAmount);\n                        }\n                        return;\n                }\n\n                // Special case for single member and empty pools\n                if (pool.length < 2) {\n                        return;\n                }\n\n                // Otherwise the award comes from the previous caller.\n                for (i = 0; i < pool.length; i++) {\n                        // Find where the member is in the pool and\n                        // award from the previous pool members bond.\n                        if (pool[i] == toCaller) {\n                                fromCaller = pool[(i + pool.length - 1) % pool.length];\n\n                                bonusAmount = _doBondBonusTransfer(fromCaller, toCaller);\n\n                                // Log the bonus was awarded.\n                                AwardedMissedBlockBonus(fromCaller, toCaller, poolNumber, callKey, block.number, bonusAmount);\n\n                                // Remove the caller from the next pool.\n                                if (getNextPoolKey() == 0) {\n                                        // This is the first address to modify the\n                                        // current pool so we need to setup the next\n                                        // pool.\n                                        _initiateNextPool();\n                                }\n                                _removeFromPool(fromCaller, getNextPoolKey());\n                                return;\n                        }\n                }\n        }\n\n        /*\n         *  Caller Pool Management\n         */\n        uint[] public poolHistory;\n        mapping (uint => address[]) callerPools;\n\n        function getPoolKeyForBlock(uint blockNumber) constant returns (uint) {\n                if (poolHistory.length == 0) {\n                        return 0;\n                }\n                for (uint i = 0; i < poolHistory.length; i++) {\n                        uint poolStartBlock = poolHistory[poolHistory.length - i - 1];\n                        if (poolStartBlock <= blockNumber) {\n                                return poolStartBlock;\n                        }\n                }\n                return 0;\n        }\n\n        function getActivePoolKey() constant returns (uint) {\n                return getPoolKeyForBlock(block.number);\n        }\n\n        function getPoolSize(uint poolKey) constant returns (uint) {\n                return callerPools[poolKey].length;\n        }\n\n        function getNextPoolKey() constant returns (uint) {\n                if (poolHistory.length == 0) {\n                        return 0;\n                }\n                uint latestPool = poolHistory[poolHistory.length - 1];\n                if (latestPool > block.number) {\n                        return latestPool;\n                }\n                return 0;\n        }\n\n        function isInAnyPool(address callerAddress) constant returns (bool) {\n                /*\n                 *  Returns boolean whether the `callerAddress` is in either\n                 *  the current active pool or the next pool.\n                 */\n                return isInPool(msg.sender, getActivePoolKey()) || isInPool(msg.sender, getNextPoolKey());\n        }\n\n        function isInPool(address callerAddress, uint poolNumber) constant returns (bool) {\n                /*\n                 *  Returns boolean whether the `callerAddress` is in the\n                 *  poolNumber.\n                 */\n                if (poolNumber == 0 ) {\n                        // Nobody can be in pool 0\n                        return false;\n                }\n\n                var pool = callerPools[poolNumber];\n\n                // Nobody is in the pool.\n                if (pool.length == 0) {\n                        return false;\n                }\n\n                for (uint i = 0; i < pool.length; i++) {\n                        // Address is in the pool and thus is allowed to exit.\n                        if (pool[i] == callerAddress) {\n                                return true;\n                        }\n                }\n\n                return false;\n        }\n\n        // Ten minutes into the future.\n        uint constant POOL_FREEZE_NUM_BLOCKS = 256;\n\n        function getPoolFreezeDuration() constant returns (uint) {\n                return POOL_FREEZE_NUM_BLOCKS;\n        }\n\n        function getPoolMinimumLength() constant returns (uint) {\n                return 2 * POOL_FREEZE_NUM_BLOCKS;\n        }\n\n        function canEnterPool(address callerAddress) constant returns (bool) {\n                /*\n                 *  Returns boolean whether `callerAddress` is allowed to enter\n                 *  the next pool (which may or may not already have been\n                 *  created.\n                 */\n                // Not allowed to join if you are in either the current\n                // active pool or the next pool.\n                if (isInAnyPool(callerAddress)) {\n                        return false;\n                }\n\n                // Next pool begins within the POOL_FREEZE_NUM_BLOCKS grace\n                // period so no changes are allowed.\n                if (getNextPoolKey() != 0 && block.number >= (getNextPoolKey() - POOL_FREEZE_NUM_BLOCKS)) {\n                        return false;\n                }\n\n                // Account bond balance is too low.\n                if (callerBonds[callerAddress] < getMinimumBond()) {\n                        return false;\n                }\n                \n                return true;\n        }\n\n        function canExitPool(address callerAddress) constant returns (bool) {\n                /*\n                 *  Returns boolean whether `callerAddress` is allowed to exit\n                 *  the current active pool.\n                 */\n                // Can't exit if we aren't in the current active pool.\n                if (!isInPool(callerAddress, getActivePoolKey())) {\n                        return false;\n                }\n\n                // There is a next pool coming up.\n                if (getNextPoolKey() != 0) {\n                        // Next pool begins within the POOL_FREEZE_NUM_BLOCKS\n                        // window and thus can't be modified.\n                        if (block.number >= (getNextPoolKey() - POOL_FREEZE_NUM_BLOCKS)) {\n                                return false;\n                        }\n\n                        // Next pool was already setup and callerAddress isn't\n                        // in it which indicates that they already left.\n                        if (!isInPool(callerAddress, getNextPoolKey())) {\n                                return false;\n                        }\n                }\n\n                // They must be in the current pool and either the next pool\n                // hasn't been initiated or it has but this user hasn't left\n                // yet.\n                return true;\n        }\n\n        function _initiateNextPool() internal {\n                if (getNextPoolKey() != 0) {\n                        // If there is already a next pool, we shouldn't\n                        // initiate a new one until it has become active.\n                        __throw();\n                }\n                // Set the next pool to start at double the freeze block number\n                // in the future.\n                uint nextPool = block.number + 2 * POOL_FREEZE_NUM_BLOCKS;\n\n                // Copy the current pool into the next pool.\n                callerPools[nextPool] = callerPools[getActivePoolKey()];\n\n                // Randomize the pool order\n                _shufflePool(nextPool);\n\n                // Push the next pool into the pool history.\n                poolHistory.length += 1;\n                poolHistory[poolHistory.length - 1] = nextPool;\n        }\n\n        function _shufflePool(uint poolNumber) internal {\n                var pool = callerPools[poolNumber];\n\n                uint swapIndex;\n                address buffer;\n\n                for (uint i = 0; i < pool.length; i++) {\n                        swapIndex = uint(sha3(block.blockhash(block.number), i)) % pool.length;\n                        if (swapIndex == i) {\n                                continue;\n                        }\n                        buffer = pool[i];\n                        pool[i] = pool[swapIndex];\n                        pool[swapIndex] = buffer;\n                }\n        }\n\n        event AddedToPool(address indexed callerAddress, uint indexed pool);\n        event RemovedFromPool(address indexed callerAddress, uint indexed pool);\n\n        function _addToPool(address callerAddress, uint poolNumber) internal {\n                if (poolNumber == 0 ) {\n                        // This shouldn't be called with 0;\n                        __throw();\n                }\n\n                // already in the pool.\n                if (isInPool(callerAddress, poolNumber)) {\n                        return;\n                }\n                var pool = callerPools[poolNumber];\n                pool.length += 1;\n                pool[pool.length - 1] = callerAddress;\n                \n                // Log the addition.\n                AddedToPool(callerAddress, poolNumber);\n        }\n\n        function _removeFromPool(address callerAddress, uint poolNumber) internal {\n                if (poolNumber == 0 ) {\n                        // This shouldn't be called with 0;\n                        __throw();\n                }\n\n                // nothing to remove.\n                if (!isInPool(callerAddress, poolNumber)) {\n                        return;\n                }\n                var pool = callerPools[poolNumber];\n                // special case length == 1\n                if (pool.length == 1) {\n                        pool.length = 0;\n                }\n                for (uint i = 0; i < pool.length; i++) {\n                        // When we find the index of the address to remove we\n                        // shift the last person to that location and then we\n                        // truncate the last member off of the end.\n                        if (pool[i] == callerAddress) {\n                                pool[i] = pool[pool.length - 1];\n                                pool.length -= 1;\n                                break;\n                        }\n                }\n\n                // Log the addition.\n                RemovedFromPool(callerAddress, poolNumber);\n        }\n\n        function enterPool() public {\n                /*\n                 *  Request to be added to the call pool.\n                 */\n                if (canEnterPool(msg.sender)) {\n                        if (getNextPoolKey() == 0) {\n                                // This is the first address to modify the\n                                // current pool so we need to setup the next\n                                // pool.\n                                _initiateNextPool();\n                        }\n                        _addToPool(msg.sender, getNextPoolKey());\n                }\n        }\n\n        function exitPool() public {\n                /*\n                 *  Request to be removed from the call pool.\n                 */\n                if (canExitPool(msg.sender)) {\n                        if (getNextPoolKey() == 0) {\n                                // This is the first address to modify the\n                                // current pool so we need to setup the next\n                                // pool.\n                                _initiateNextPool();\n                        }\n                        _removeFromPool(msg.sender, getNextPoolKey());\n                }\n        }\n\n        function __throw() internal {\n                int[] x;\n                x[1];\n        }\n}\n\n\ncontract GroveAPI {\n        function getIndexId(address ownerAddress, bytes32 indexName) constant returns (bytes32);\n        function insert(bytes32 indexName, bytes32 id, int value) public;\n}\n\n\ncontract Alarm {\n        /*\n         *  Administration API\n         *\n         *  There is currently no special administrative API beyond the hard\n         *  coded owner address which receives 1% of each executed call.  This\n         *  eliminates any need for trust as nobody has any special access.\n         */\n        function Alarm() {\n                unauthorizedRelay = new Relay();\n                authorizedRelay = new Relay();\n                callerPool = new CallerPool();\n        }\n\n        address constant owner = 0xd3cda913deb6f67967b99d67acdfa1712c293601;\n\n        // The deployed grove contract for call tree tracking.\n        GroveAPI grove = GroveAPI(0xfe9d4e5717ec0e16f8301240df5c3f7d3e9effef);\n\n        /*\n         *  Account Management API\n         */\n        mapping (address => uint) public accountBalances;\n\n        function _deductFunds(address accountAddress, uint value) internal {\n                /*\n                 *  Helper function that should be used for any reduction of\n                 *  account funds.  It has error checking to prevent\n                 *  underflowing the account balance which would be REALLY bad.\n                 */\n                if (value > accountBalances[accountAddress]) {\n                        // Prevent Underflow.\n                        __throw();\n                }\n                accountBalances[accountAddress] -= value;\n        }\n\n        function _addFunds(address accountAddress, uint value) internal {\n                /*\n                 *  Helper function that should be used for any addition of\n                 *  account funds.  It has error checking to prevent\n                 *  overflowing the account balance.\n                 */\n                if (accountBalances[accountAddress] + value < accountBalances[accountAddress]) {\n                        // Prevent Overflow.\n                        __throw();\n                }\n                accountBalances[accountAddress] += value;\n        }\n\n        event Deposit(address indexed _from, address indexed accountAddress, uint value);\n\n        function deposit(address accountAddress) public {\n                /*\n                 *  Public API for depositing funds in a specified account.\n                 */\n                _addFunds(accountAddress, msg.value);\n                Deposit(msg.sender, accountAddress, msg.value);\n        }\n\n        event Withdraw(address indexed accountAddress, uint value);\n\n        function withdraw(uint value) public {\n                /*\n                 *  Public API for withdrawing funds.\n                 */\n                if (accountBalances[msg.sender] >= value) {\n                        _deductFunds(msg.sender, value);\n                        if (!msg.sender.send(value)) {\n                                // Potentially sending money to a contract that\n                                // has a fallback function.  So instead, try\n                                // tranferring the funds with the call api.\n                                if (!msg.sender.call.gas(msg.gas).value(value)()) {\n                                        // Revert the entire transaction.  No\n                                        // need to destroy the funds.\n                                        __throw();\n                                }\n                        }\n                        Withdraw(msg.sender, value);\n                }\n        }\n\n        function() {\n                /*\n                 *  Fallback function that allows depositing funds just by\n                 *  sending a transaction.\n                 */\n                _addFunds(msg.sender, msg.value);\n                Deposit(msg.sender, msg.sender, msg.value);\n        }\n\n        /*\n         *  Scheduling Authorization API\n         */\n        Relay unauthorizedRelay;\n        Relay authorizedRelay;\n\n        function unauthorizedAddress() constant returns (address) {\n                return address(unauthorizedRelay);\n        }\n\n        function authorizedAddress() constant returns (address) {\n                return address(authorizedRelay);\n        }\n\n        mapping (bytes32 => bool) accountAuthorizations;\n\n        function addAuthorization(address schedulerAddress) public {\n                accountAuthorizations[sha3(schedulerAddress, msg.sender)] = true;\n        }\n\n        function removeAuthorization(address schedulerAddress) public {\n                accountAuthorizations[sha3(schedulerAddress, msg.sender)] = false;\n        }\n\n        function checkAuthorization(address schedulerAddress, address contractAddress) constant returns (bool) {\n                return accountAuthorizations[sha3(schedulerAddress, contractAddress)];\n        }\n\n        /*\n         *  Call Information API\n         */\n        bytes32 lastCallKey;\n\n        function getLastCallKey() constant returns (bytes32) {\n                return lastCallKey;\n        }\n\n        struct Call {\n                address contractAddress;\n                address scheduledBy;\n                uint calledAtBlock;\n                uint targetBlock;\n                uint8 gracePeriod;\n                uint nonce;\n                uint baseGasPrice;\n                uint gasPrice;\n                uint gasUsed;\n                uint gasCost;\n                uint payout;\n                uint fee;\n                address executedBy;\n                bytes4 abiSignature;\n                bool isCancelled;\n                bool wasCalled;\n                bool wasSuccessful;\n                bytes32 dataHash;\n        }\n\n        mapping (bytes32 => Call) key_to_calls;\n\n        /*\n         *  Getter methods for `Call` information\n         */\n        function getCallContractAddress(bytes32 callKey) constant returns (address) {\n                return key_to_calls[callKey].contractAddress;\n        }\n\n        function getCallScheduledBy(bytes32 callKey) constant returns (address) {\n                return key_to_calls[callKey].scheduledBy;\n        }\n\n        function getCallCalledAtBlock(bytes32 callKey) constant returns (uint) {\n                return key_to_calls[callKey].calledAtBlock;\n        }\n\n        function getCallGracePeriod(bytes32 callKey) constant returns (uint) {\n                return key_to_calls[callKey].gracePeriod;\n        }\n\n        function getCallTargetBlock(bytes32 callKey) constant returns (uint) {\n                return key_to_calls[callKey].targetBlock;\n        }\n\n        function getCallBaseGasPrice(bytes32 callKey) constant returns (uint) {\n                return key_to_calls[callKey].baseGasPrice;\n        }\n\n        function getCallGasPrice(bytes32 callKey) constant returns (uint) {\n                return key_to_calls[callKey].gasPrice;\n        }\n\n        function getCallGasUsed(bytes32 callKey) constant returns (uint) {\n                return key_to_calls[callKey].gasUsed;\n        }\n\n        function getCallABISignature(bytes32 callKey) constant returns (bytes4) {\n                return key_to_calls[callKey].abiSignature;\n        }\n\n        function checkIfCalled(bytes32 callKey) constant returns (bool) {\n                return key_to_calls[callKey].wasCalled;\n        }\n\n        function checkIfSuccess(bytes32 callKey) constant returns (bool) {\n                return key_to_calls[callKey].wasSuccessful;\n        }\n\n        function checkIfCancelled(bytes32 callKey) constant returns (bool) {\n                return key_to_calls[callKey].isCancelled;\n        }\n\n        function getCallDataHash(bytes32 callKey) constant returns (bytes32) {\n                return key_to_calls[callKey].dataHash;\n        }\n\n        function getCallPayout(bytes32 callKey) constant returns (uint) {\n                return key_to_calls[callKey].payout;\n        }\n\n        function getCallFee(bytes32 callKey) constant returns (uint) {\n                return key_to_calls[callKey].fee;\n        }\n\n        /*\n         *  Data Registry API\n         */\n        bytes lastData;\n        uint lastDataLength;\n        bytes32 lastDataHash;\n\n        function getLastDataHash() constant returns (bytes32) {\n                return lastDataHash;\n        }\n\n        function getLastDataLength() constant returns (uint) {\n                return lastDataLength;\n        }\n\n        function getLastData() constant returns (bytes) {\n                return lastData;\n        }\n\n        function getCallData(bytes32 callKey) constant returns (bytes) {\n                return hash_to_data[key_to_calls[callKey].dataHash];\n        }\n\n        mapping (bytes32 => bytes) hash_to_data;\n\n        /*\n         *  Data registration API\n         */\n        //event DataRegistered(bytes32 indexed dataHash);\n\n        function registerData() public {\n                lastData.length = msg.data.length - 4;\n                if (msg.data.length > 4) {\n                        for (uint i = 0; i < lastData.length; i++) {\n                                lastData[i] = msg.data[i + 4];\n                        }\n                }\n                hash_to_data[sha3(lastData)] = lastData;\n                lastDataHash = sha3(lastData);\n                lastDataLength = lastData.length;\n                lastData = lastData;\n\n                // Log it.\n                //DataRegistered(lastDataHash);\n        }\n\n        /*\n         *  Call execution API\n         */\n        CallerPool callerPool;\n\n        function getCallerPoolAddress() constant returns (address) {\n                return address(callerPool);\n        }\n\n        // This number represents the constant gas cost of the addition\n        // operations that occur in `doCall` that cannot be tracked with\n        // msg.gas.\n        uint constant EXTRA_CALL_GAS = 151098;\n\n        // This number represents the overall overhead involved in executing a\n        // scheduled call.\n        uint constant CALL_OVERHEAD = 144982;\n\n        event CallExecuted(address indexed executedBy, bytes32 indexed callKey);\n        event CallAborted(address indexed executedBy, bytes32 indexed callKey, bytes18 reason);\n\n        function doCall(bytes32 callKey) public {\n                uint gasBefore = msg.gas;\n\n                var call = key_to_calls[callKey];\n\n                if (call.wasCalled) {\n                        // The call has already been executed so don't do it again.\n                        CallAborted(msg.sender, callKey, \"ALREADY CALLED\");\n                        return;\n                }\n\n                if (call.isCancelled) {\n                        // The call was cancelled so don't execute it.\n                        CallAborted(msg.sender, callKey, \"CANCELLED\");\n                        return;\n                }\n\n                if (call.contractAddress == 0x0) {\n                        // This call key doesnt map to a registered call.\n                        CallAborted(msg.sender, callKey, \"UNKNOWN\");\n                        return;\n                }\n\n                if (block.number < call.targetBlock) {\n                        // Target block hasnt happened yet.\n                        CallAborted(msg.sender, callKey, \"TOO EARLY\");\n                        return;\n                }\n\n                if (block.number > call.targetBlock + call.gracePeriod) {\n                        // The blockchain has advanced passed the period where\n                        // it was allowed to be called.\n                        CallAborted(msg.sender, callKey, \"TOO LATE\");\n                        return;\n                }\n\n                uint heldBalance = getCallMaxCost(callKey);\n\n                if (accountBalances[call.scheduledBy] < heldBalance) {\n                        // The scheduledBy's account balance is less than the\n                        // current gasLimit and thus potentiall can't pay for\n                        // the call.\n\n                        // Mark it as called since it was.\n                        call.wasCalled = true;\n                        \n                        // Log it.\n                        CallAborted(msg.sender, callKey, \"INSUFFICIENT_FUNDS\");\n                        return;\n                }\n\n                // Check if this caller is allowed to execute the call.\n                if (callerPool.getPoolSize(callerPool.getActivePoolKey()) > 0) {\n                        address poolCaller = callerPool.getDesignatedCaller(callKey, call.targetBlock, call.gracePeriod, block.number);\n                        if (poolCaller != 0x0 && poolCaller != msg.sender) {\n                                // This call was reserved for someone from the\n                                // bonded pool of callers and can only be\n                                // called by them during this block window.\n                                CallAborted(msg.sender, callKey, \"WRONG_CALLER\");\n                                return;\n                        }\n\n                        uint blockWindow = (block.number - call.targetBlock) / 4;\n                        if (blockWindow > 0) {\n                                // Someone missed their call so this caller\n                                // gets to claim their bond for picking up\n                                // their slack.\n                                callerPool.awardMissedBlockBonus(msg.sender, callKey, call.targetBlock, call.gracePeriod);\n                        }\n                }\n\n                // Log metadata about the call.\n                call.gasPrice = tx.gasprice;\n                call.executedBy = msg.sender;\n                call.calledAtBlock = block.number;\n\n                // Fetch the call data\n                var data = getCallData(callKey);\n\n                // During the call, we need to put enough funds to pay for the\n                // call on hold to ensure they are available to pay the caller.\n                _deductFunds(call.scheduledBy, heldBalance);\n\n                // Mark whether the function call was successful.\n                if (checkAuthorization(call.scheduledBy, call.contractAddress)) {\n                        call.wasSuccessful = authorizedRelay.relayCall.gas(msg.gas - CALL_OVERHEAD)(call.contractAddress, call.abiSignature, data);\n                }\n                else {\n                        call.wasSuccessful = unauthorizedRelay.relayCall.gas(msg.gas - CALL_OVERHEAD)(call.contractAddress, call.abiSignature, data);\n                }\n\n                // Add the held funds back into the scheduler's account.\n                _addFunds(call.scheduledBy, heldBalance);\n\n                // Mark the call as having been executed.\n                call.wasCalled = true;\n\n                // Log the call execution.\n                CallExecuted(msg.sender, callKey);\n\n                // Compute the scalar (0 - 200) for the fee.\n                uint feeScalar = getCallFeeScalar(call.baseGasPrice, call.gasPrice);\n\n                // Log how much gas this call used.  EXTRA_CALL_GAS is a fixed\n                // amount that represents the gas usage of the commands that\n                // happen after this line.\n                call.gasUsed = (gasBefore - msg.gas + EXTRA_CALL_GAS);\n                call.gasCost = call.gasUsed * call.gasPrice;\n\n                // Now we need to pay the caller as well as keep fee.\n                // callerPayout -> call cost + 1%\n                // fee -> 1% of callerPayout\n                call.payout = call.gasCost * feeScalar * 101 / 10000;\n                call.fee = call.gasCost * feeScalar / 10000;\n\n                _deductFunds(call.scheduledBy, call.payout + call.fee);\n\n                _addFunds(msg.sender, call.payout);\n                _addFunds(owner, call.fee);\n        }\n\n        function getCallMaxCost(bytes32 callKey) constant returns (uint) {\n                /*\n                 *  tx.gasprice * block.gaslimit\n                 *  \n                 */\n                // call cost + 2%\n                var call = key_to_calls[callKey];\n\n                uint gasCost = tx.gasprice * block.gaslimit;\n                uint feeScalar = getCallFeeScalar(call.baseGasPrice, tx.gasprice);\n\n                return gasCost * feeScalar * 102 / 10000;\n        }\n\n        function getCallFeeScalar(uint baseGasPrice, uint gasPrice) constant returns (uint) {\n                /*\n                 *  Return a number between 0 - 200 to scale the fee based on\n                 *  the gas price set for the calling transaction as compared\n                 *  to the gas price of the scheduling transaction.\n                 *\n                 *  - number approaches zero as the transaction gas price goes\n                 *  above the gas price recorded when the call was scheduled.\n                 *\n                 *  - the number approaches 200 as the transaction gas price\n                 *  drops under the price recorded when the call was scheduled.\n                 *\n                 *  This encourages lower gas costs as the lower the gas price\n                 *  for the executing transaction, the higher the payout to the\n                 *  caller.\n                 */\n                if (gasPrice > baseGasPrice) {\n                        return 100 * baseGasPrice / gasPrice;\n                }\n                else {\n                        return 200 - 100 * baseGasPrice / (2 * baseGasPrice - gasPrice);\n                }\n        }\n\n        /*\n         *  Call Scheduling API\n         */\n\n        // The result of `sha()` so that we can validate that people aren't\n        // looking up call data that failed to register.\n        bytes32 constant emptyDataHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n\n        function getCallKey(address scheduledBy, address contractAddress, bytes4 abiSignature, bytes32 dataHash, uint targetBlock, uint8 gracePeriod, uint nonce) constant returns (bytes32) {\n                return sha3(scheduledBy, contractAddress, abiSignature, dataHash, targetBlock, gracePeriod, nonce);\n        }\n\n        // Ten minutes into the future.\n        uint constant MAX_BLOCKS_IN_FUTURE = 40;\n\n        event CallScheduled(bytes32 indexed callKey);\n        //event CallRejected(bytes32 indexed callKey, bytes15 reason);\n\n        function scheduleCall(address contractAddress, bytes4 abiSignature, bytes32 dataHash, uint targetBlock) public {\n                /*\n                 *  Schedule call with gracePeriod defaulted to 255 and nonce\n                 *  defaulted to 0.\n                 */\n                scheduleCall(contractAddress, abiSignature, dataHash, targetBlock, 255, 0);\n        }\n\n        function scheduleCall(address contractAddress, bytes4 abiSignature, bytes32 dataHash, uint targetBlock, uint8 gracePeriod) public {\n                /*\n                 *  Schedule call with nonce defaulted to 0.\n                 */\n                scheduleCall(contractAddress, abiSignature, dataHash, targetBlock, gracePeriod, 0);\n        }\n\n        function scheduleCall(address contractAddress, bytes4 abiSignature, bytes32 dataHash, uint targetBlock, uint8 gracePeriod, uint nonce) public {\n                /*\n                 * Primary API for scheduling a call.  Prior to calling this\n                 * the data should already have been registered through the\n                 * `registerData` API.\n                 */\n                bytes32 callKey = getCallKey(msg.sender, contractAddress, abiSignature, dataHash, targetBlock, gracePeriod, nonce);\n\n                if (dataHash != emptyDataHash && hash_to_data[dataHash].length == 0) {\n                        // Don't allow registering calls if the data hash has\n                        // not actually been registered.  The only exception is\n                        // the *emptyDataHash*.\n                        //CallRejected(callKey, \"NO_DATA\");\n                        return;\n                }\n\n                if (targetBlock < block.number + MAX_BLOCKS_IN_FUTURE) {\n                        // Don't allow scheduling further than\n                        // MAX_BLOCKS_IN_FUTURE\n                        //CallRejected(callKey, \"TOO_SOON\");\n                        return;\n                }\n                var call = key_to_calls[callKey];\n\n                if (call.contractAddress != 0x0) {\n                        //CallRejected(callKey, \"DUPLICATE\");\n                        return;\n                }\n\n                if (gracePeriod < 16) {\n                        //CallRejected(callKey, \"GRACE_TOO_SHORT\");\n                        return;\n                }\n\n                lastCallKey = callKey;\n\n                call.contractAddress = contractAddress;\n                call.scheduledBy = msg.sender;\n                call.nonce = nonce;\n                call.abiSignature = abiSignature;\n                call.dataHash = dataHash;\n                call.targetBlock = targetBlock;\n                call.gracePeriod = gracePeriod;\n                call.baseGasPrice = tx.gasprice;\n\n                // Put the call into the grove index.\n                grove.insert(GROVE_INDEX_NAME, lastCallKey, int(call.targetBlock));\n\n                CallScheduled(lastCallKey);\n        }\n\n        bytes32 constant GROVE_INDEX_NAME = \"callTargetBlock\";\n\n        function getGroveAddress() constant returns (address) {\n                return address(grove);\n        }\n\n        function getGroveIndexName() constant returns (bytes32) {\n                return GROVE_INDEX_NAME;\n        }\n\n        function getGroveIndexId() constant returns (bytes32) {\n                return grove.getIndexId(address(this), GROVE_INDEX_NAME);\n        }\n\n        //event CallCancelled(bytes32 indexed callKey);\n\n        // Two minutes\n        uint constant MIN_CANCEL_WINDOW = 8;\n\n        function cancelCall(bytes32 callKey) public {\n                var call = key_to_calls[callKey];\n                if (call.scheduledBy != msg.sender) {\n                        // Nobody but the scheduler can cancel a call.\n                        return;\n                }\n                if (call.wasCalled) {\n                        // No need to cancel a call that already was executed.\n                        return;\n                }\n                if (call.targetBlock - MIN_CANCEL_WINDOW <= block.number) {\n                        // Call cannot be cancelled this close to execution.\n                        return;\n                }\n                call.isCancelled = true;\n                //CallCancelled(callKey);\n        }\n\n        function __throw() internal {\n                int[] x;\n                x[1];\n        }\n}\n",
            "userDoc": {
                "methods": {}
            }
        }
    },
    "Grove": {
        "code": "0x6060604052611003806100126000396000f3606060405236156100cf5760e060020a6000350463190a861381146100d1578063419308f7146100ef5780638148d2fe1461011657806382ac1d991461014057806384987faa1461015d5780638683612b1461017a578063870e5405146101915780639a04fc8b146101b55780639c05ba60146101d2578063ada5ba01146101ec578063af82403c1461020a578063b10e417214610231578063bdf7716d14610253578063c62aa67d14610270578063ce7cdbb71461028d578063d2bbf6df146102a7578063d76d6ee0146102f7575b005b6103206004356000818152600160205260409020600501545b919050565b6103206004355b600081815260016020526040812080548290819081141561033f57610337565b6103206004356024355b604080518381526020810183905281519081900390910190205b92915050565b6103206004356000818152600160205260409020600301546100ea565b6103206004356000818152600160205260409020600601546100ea565b6103206004356024356000600061062c8484610120565b6100cf60043560243560443560006000600060006000600060006104a4338b6102b1565b6103206004356000818152600160205260409020600401546100ea565b6103206004356000818152600260205260409020546100ea565b610320600435600081815260016020819052604090912001546100ea565b6103206004355b60008181526001602052604081208054829081908114156103f457610337565b6100cf6004356024355b6000600060006000600060006000610644338a6102b1565b6103206004356000818152600160205260409020600701546100ea565b6103206004356000818152600160205260409020600201546100ea565b6103206004356000818152602081905260409020546100ea565b6103206004356024355b6040805173ffffffffffffffffffffffffffffffffffffffff84166c0100000000000000000000000002815260148101839052905160349181900391909101902061013a565b61032060043560243560443560008381526020819052604081205481818114156109595761097e565b60408051918252519081900360200190f35b815493505b505050919050565b6005830154600014610388576005830154600090815260016020526040902091505b60068201546000146103325760069190910154600090815260016020526040902090610361565b60048301546000146103d05750506004810154600090815260016020526040902081905b8154600682015414156103c25780549350610337565b6004810154600014156103d9575b60009350610337565b600481015460009081526001602052604090209091506103ac565b600683015460001461043d576006830154600090815260016020526040902091505b60058201546000146103325760059190910154600090815260016020526040902090610416565b60048301546000146103d05750506004810154600090815260016020526040902081905b8154600582015414156104775780549350610337565b600481015460001415610489576103d0565b60048101546000908152600160205260409020909150610461565b60008181526002602052604081205491985014156104c55760406000208a90555b6104cf878a610120565b60008181526001602052604090205490965086141561050f57604060002060030154881415610505575b50505050505050505050565b61050f8a8a61023b565b60008781526020819052604081205490935091508183141561053657604083208690558591505b5060008181526001602052604090205b6001810154600014156105c557858155600481018390556001810187905560028101899055600381018890556104f9865b6000818152600160205260408120905b8154610c85905b6000818152600160205260408082206006810154835281832060079081015460058301548552929093209092015403905b50919050565b6003810154815493508812610600576006810154600014156105e957600681018690555b600601546000908152600160205260409020610546565b60058101546000141561061557600581018690555b600501546000908152600160205260409020610546565b60008181526001602052604090205414949350505050565b96506106508789610120565b600081815260016020526040902060028101549197509150881461067a575b505050505050505050565b6005810154600014158061069357506006810154600014155b156106b557600581015460001461070a57805460019060009061071b906100f6565b600481015460001461090b57600481015460009081526001602052604090206005810154825491955014156106ec57600060058501555b60068401548154141561070157600060068501555b8354915061091b565b805460019060009061073290610211565b815260208101919091526040016000209450610745565b8152602081019190915260400160002094505b6004850154600090815260016020526040902060058101548654919550909250821415610797576006850154600585018190556000146107975760068501546000908152604090208454600482015592505b6006840154855414156107ef576005850154600685018190556000146107ef57600160005060008660050160005054815260200190815260200160002060005092508250836000016000505483600401600050819055505b60048181015490860181905560001461085e5760016000506000826004016000505481526020019081526020016000206000509350835080600001600050548460050160005054141561084457845460058501555b60068401548154141561085957845460068501555b610870565b84546000888152602081905260409020555b6005818101549086018190556000146108bb57600160005060008260050160005054815260200190815260200160002060005092508250846000016000505483600401600050819055505b60068181015490860181905560001461090657600160005060008260060160005054815260200190815260200160002060005092508250846000016000505483600401600050819055505b61091b565b6000878152602081905260408120555b6000600282018190558082556001820181905560038201819055600482018190556005820181905560068201819055821461066f5761066f82610577565b5060008181526001602052604090205b60038101546109879086866109c6565b805492505b50509392505050565b15610a7e5760fa60020a600f028514806109a8575060f060020a613c3d0285145b156109e357600681015460001415610a2c578054925061097e565b86865b600060f960020a601f02831415610bc757508083135b9392505050565b60f960020a601f028514806109ff575060f060020a613e3d0285145b80610a11575060f060020a613d3d0285145b15610a7e57600581015460001415610ab5578054925061097e565b610a626109c3826006016000505460008181526001602052604081205b600581015460001415610c5b57600381015491506105bf565b1561097957600601546000908152600160205260409020610969565b60fa60020a600f02851480610a9a575060f060020a613c3d0285145b15610b0757600581015460001415610b3e576000925061097e565b610aeb6109c3826005016000505460008181526001602052604081205b600681015460001415610c4457600381015491506105bf565b1561097957600501546000908152600160205260409020610969565b60f960020a601f02851480610b23575060f060020a613e3d0285145b15610b5557600681015460001415610b88576000925061097e565b600501546000908152600160205260409020610969565b60f060020a613d3d02851415610bc257600381015484901215610b9f57600681015460001415610b88576000925061097e565b600601546000908152600160205260409020610969565b600381015484901315610bc257600581015460001415610b3e576000925061097e565b610969565b60fa60020a600f02831415610bdf57508083126109dc565b60f060020a613e3d02831415610bf95750808312156109dc565b60f060020a613c3d02831415610c135750808313156109dc565b60f060020a613d3d02831415610c2c57508281146109dc565b6109dc5b600080600181548110156100025750508052565b600601546000908152600160205260409020610ad2565b600501546000908152600160205260409020610a49565b600482015460001415610eb3575b505050565b90508060021415610d15576005820154610c9e9061058e565b6000191415610cb5576005820154610cb590610cec565b8154610d15905b6000818152600160205260408120600581015490919081908190811415610eec57610eec610c30565b8154610d43905b6000818152600160205260408120600681015490919081908190811415610d6657610d66610c30565b806001191415610d43576006820154610d2d9061058e565b60011415610ce5576006820154610ce590610cbc565b8060001913158015610d56575060018113155b15610c72578154610c7290610e72565b600684018054600090815260016020526040812060048781015490820181905592829055945014610df25760016000506000856004016000505481526020019081526020016000206000509150836000016000505482600501600050541415610ddd57826000016000505482600501600050819055505b835460068301541415610df257825460068301555b6005830154600014610e2157506005820154600090815260016020526040902080546006850155835460048201555b82546004858101919091558454600585015583015460001415610e6b5782600001600050546000600050600085600101600050548152602001908152602001600020600050819055505b8354610eda905b600081815260016020526040808220600581015483528183206007908101546006830154855292842001549092610ece929190818310610ffc57508161013a565b60049190910154600090815260016020526040902090610587565b60010160078201555050565b8254610ee590610e72565b5050505050565b600584018054600090815260016020526040812060048781015490820181905592829055945014610f785760016000506000856004016000505481526020019081526020016000206000509150836000016000505482600501600050541415610f6357826000016000505482600501600050819055505b835460068301541415610f7857825460068301555b6006830154600014610fa85750600682015460008181526001602052604090206005850191909155835460048201555b82546004858101919091558454600685015583015460001415610e6b5782600001600050546000600050600085600101600050548152602001908152602001600020600050819055508354610eda90610e72565b508061013a56",
        "info": {
            "abiDefinition": [
                {
                    "constant": true,
                    "inputs": [
                        {
                            "name": "nodeId",
                            "type": "bytes32"
                        }
                    ],
                    "name": "getNodeLeftChild",
                    "outputs": [
                        {
                            "name": "",
                            "type": "bytes32"
                        }
                    ],
                    "type": "function"
                },
                {
                    "constant": true,
                    "inputs": [
                        {
                            "name": "nodeId",
                            "type": "bytes32"
                        }
                    ],
                    "name": "getPreviousNode",
                    "outputs": [
                        {
                            "name": "",
                            "type": "bytes32"
                        }
                    ],
                    "type": "function"
                },
                {
                    "constant": true,
                    "inputs": [
                        {
                            "name": "indexId",
                            "type": "bytes32"
                        },
                        {
                            "name": "id",
                            "type": "bytes32"
                        }
                    ],
                    "name": "getNodeId",
                    "outputs": [
                        {
                            "name": "",
                            "type": "bytes32"
                        }
                    ],
                    "type": "function"
                },
                {
                    "constant": true,
                    "inputs": [
                        {
                            "name": "nodeId",
                            "type": "bytes32"
                        }
                    ],
                    "name": "getNodeValue",
                    "outputs": [
                        {
                            "name": "",
                            "type": "int256"
                        }
                    ],
                    "type": "function"
                },
                {
                    "constant": true,
                    "inputs": [
                        {
                            "name": "nodeId",
                            "type": "bytes32"
                        }
                    ],
                    "name": "getNodeRightChild",
                    "outputs": [
                        {
                            "name": "",
                            "type": "bytes32"
                        }
                    ],
                    "type": "function"
                },
                {
                    "constant": true,
                    "inputs": [
                        {
                            "name": "indexId",
                            "type": "bytes32"
                        },
                        {
                            "name": "id",
                            "type": "bytes32"
                        }
                    ],
                    "name": "exists",
                    "outputs": [
                        {
                            "name": "",
                            "type": "bool"
                        }
                    ],
                    "type": "function"
                },
                {
                    "constant": false,
                    "inputs": [
                        {
                            "name": "indexName",
                            "type": "bytes32"
                        },
                        {
                            "name": "id",
                            "type": "bytes32"
                        },
                        {
                            "name": "value",
                            "type": "int256"
                        }
                    ],
                    "name": "insert",
                    "outputs": [],
                    "type": "function"
                },
                {
                    "constant": true,
                    "inputs": [
                        {
                            "name": "nodeId",
                            "type": "bytes32"
                        }
                    ],
                    "name": "getNodeParent",
                    "outputs": [
                        {
                            "name": "",
                            "type": "bytes32"
                        }
                    ],
                    "type": "function"
                },
                {
                    "constant": true,
                    "inputs": [
                        {
                            "name": "indexId",
                            "type": "bytes32"
                        }
                    ],
                    "name": "getIndexName",
                    "outputs": [
                        {
                            "name": "",
                            "type": "bytes32"
                        }
                    ],
                    "type": "function"
                },
                {
                    "constant": true,
                    "inputs": [
                        {
                            "name": "nodeId",
                            "type": "bytes32"
                        }
                    ],
                    "name": "getNodeIndexId",
                    "outputs": [
                        {
                            "name": "",
                            "type": "bytes32"
                        }
                    ],
                    "type": "function"
                },
                {
                    "constant": true,
                    "inputs": [
                        {
                            "name": "nodeId",
                            "type": "bytes32"
                        }
                    ],
                    "name": "getNextNode",
                    "outputs": [
                        {
                            "name": "",
                            "type": "bytes32"
                        }
                    ],
                    "type": "function"
                },
                {
                    "constant": false,
                    "inputs": [
                        {
                            "name": "indexName",
                            "type": "bytes32"
                        },
                        {
                            "name": "id",
                            "type": "bytes32"
                        }
                    ],
                    "name": "remove",
                    "outputs": [],
                    "type": "function"
                },
                {
                    "constant": true,
                    "inputs": [
                        {
                            "name": "nodeId",
                            "type": "bytes32"
                        }
                    ],
                    "name": "getNodeHeight",
                    "outputs": [
                        {
                            "name": "",
                            "type": "uint256"
                        }
                    ],
                    "type": "function"
                },
                {
                    "constant": true,
                    "inputs": [
                        {
                            "name": "nodeId",
                            "type": "bytes32"
                        }
                    ],
                    "name": "getNodeId",
                    "outputs": [
                        {
                            "name": "",
                            "type": "bytes32"
                        }
                    ],
                    "type": "function"
                },
                {
                    "constant": true,
                    "inputs": [
                        {
                            "name": "indexId",
                            "type": "bytes32"
                        }
                    ],
                    "name": "getIndexRoot",
                    "outputs": [
                        {
                            "name": "",
                            "type": "bytes32"
                        }
                    ],
                    "type": "function"
                },
                {
                    "constant": true,
                    "inputs": [
                        {
                            "name": "owner",
                            "type": "address"
                        },
                        {
                            "name": "indexName",
                            "type": "bytes32"
                        }
                    ],
                    "name": "getIndexId",
                    "outputs": [
                        {
                            "name": "",
                            "type": "bytes32"
                        }
                    ],
                    "type": "function"
                },
                {
                    "constant": false,
                    "inputs": [
                        {
                            "name": "indexId",
                            "type": "bytes32"
                        },
                        {
                            "name": "operator",
                            "type": "bytes2"
                        },
                        {
                            "name": "value",
                            "type": "int256"
                        }
                    ],
                    "name": "query",
                    "outputs": [
                        {
                            "name": "",
                            "type": "bytes32"
                        }
                    ],
                    "type": "function"
                }
            ],
            "compilerVersion": "0.1.3-1736fe80",
            "developerDoc": {
                "methods": {}
            },
            "language": "Solidity",
            "languageVersion": "0",
            "source": "contract Grove {\n        /*\n         *  Call tracking API\n         */\n        struct Node {\n                bytes32 nodeId;\n                bytes32 indexId;\n                bytes32 id;\n                int value;\n                bytes32 parent;\n                bytes32 left;\n                bytes32 right;\n                uint height;\n        }\n\n        // Maps an index id to the id of it's root node.\n        mapping (bytes32 => bytes32) index_to_root;\n\n        // Maps node_id to Node\n        mapping (bytes32 => Node) node_lookup;\n\n        // Map index_id to index Name\n        mapping (bytes32 => bytes32) index_lookup;\n\n        function getIndexId(address owner, bytes32 indexName) constant returns (bytes32) {\n                return sha3(owner, indexName);\n        }\n\n        function getNodeId(bytes32 indexId, bytes32 id) constant returns (bytes32) {\n                return sha3(indexId, id);\n        }\n\n        function max(uint a, uint b) internal returns (uint) {\n            if (a >= b) {\n                return a;\n            }\n            return b;\n        }\n\n        /*\n         *  Node getters\n         */\n        function getIndexName(bytes32 indexId) constant returns (bytes32) {\n            return index_lookup[indexId];\n        }\n\n        function getIndexRoot(bytes32 indexId) constant returns (bytes32) {\n            return index_to_root[indexId];\n        }\n\n        function getNodeId(bytes32 nodeId) constant returns (bytes32) {\n            return node_lookup[nodeId].id;\n        }\n\n        function getNodeIndexId(bytes32 nodeId) constant returns (bytes32) {\n            return node_lookup[nodeId].indexId;\n        }\n\n        function getNodeValue(bytes32 nodeId) constant returns (int) {\n            return node_lookup[nodeId].value;\n        }\n\n        function getNodeHeight(bytes32 nodeId) constant returns (uint) {\n            return node_lookup[nodeId].height;\n        }\n\n        function getNodeParent(bytes32 nodeId) constant returns (bytes32) {\n            return node_lookup[nodeId].parent;\n        }\n\n        function getNodeLeftChild(bytes32 nodeId) constant returns (bytes32) {\n            return node_lookup[nodeId].left;\n        }\n\n        function getNodeRightChild(bytes32 nodeId) constant returns (bytes32) {\n            return node_lookup[nodeId].right;\n        }\n\n        function getPreviousNode(bytes32 nodeId) constant returns (bytes32) {\n            var currentNode = node_lookup[nodeId];\n\n            if (currentNode.nodeId == 0x0) {\n                // Unknown node, just return 0x0;\n                return 0x0;\n            }\n\n            Node child;\n\n            if (currentNode.left != 0x0) {\n                // Trace left to latest child in left tree.\n                child = node_lookup[currentNode.left];\n\n                while (child.right != 0) {\n                    child = node_lookup[child.right];\n                }\n                return child.nodeId;\n            }\n\n            if (currentNode.parent != 0x0) {\n                // Now we trace back up through parent relationships, looking\n                // for a link where the child is the right child of it's\n                // parent.\n                var parent = node_lookup[currentNode.parent];\n                child = currentNode;\n\n                while (true) {\n                    if (parent.right == child.nodeId) {\n                        return parent.nodeId;\n                    }\n\n                    if (parent.parent == 0x0) {\n                        break;\n                    }\n                    child = parent;\n                    parent = node_lookup[parent.parent];\n                }\n            }\n\n            // This is the first node, and has no previous node.\n            return 0x0;\n        }\n\n        function getNextNode(bytes32 nodeId) constant returns (bytes32) {\n            var currentNode = node_lookup[nodeId];\n\n            if (currentNode.nodeId == 0x0) {\n                // Unknown node, just return 0x0;\n                return 0x0;\n            }\n\n            Node child;\n\n            if (currentNode.right != 0x0) {\n                // Trace right to earliest child in right tree.\n                child = node_lookup[currentNode.right];\n\n                while (child.left != 0) {\n                    child = node_lookup[child.left];\n                }\n                return child.nodeId;\n            }\n\n            if (currentNode.parent != 0x0) {\n                // if the node is the left child of it's parent, then the\n                // parent is the next one.\n                var parent = node_lookup[currentNode.parent];\n                child = currentNode;\n\n                while (true) {\n                    if (parent.left == child.nodeId) {\n                        return parent.nodeId;\n                    }\n\n                    if (parent.parent == 0x0) {\n                        break;\n                    }\n                    child = parent;\n                    parent = node_lookup[parent.parent];\n                }\n\n                // Now we need to trace all the way up checking to see if any parent is the \n            }\n\n            // This is the final node.\n            return 0x0;\n        }\n\n        function insert(bytes32 indexName, bytes32 id, int value) public {\n                bytes32 indexId = getIndexId(msg.sender, indexName);\n                if (index_lookup[indexId] == 0x0) {\n                    index_lookup[indexId] = indexName;\n                }\n                bytes32 nodeId = getNodeId(indexId, id);\n\n                if (node_lookup[nodeId].nodeId == nodeId) {\n                    // A node with this id already exists.  If the value is\n                    // the same, then just return early, otherwise, remove it\n                    // and reinsert it.\n                    if (node_lookup[nodeId].value == value) {\n                        return;\n                    }\n                    remove(indexName, id);\n                }\n\n                uint leftHeight;\n                uint rightHeight;\n\n                bytes32 previousNodeId = 0x0;\n\n                bytes32 rootNodeId = index_to_root[indexId];\n\n                if (rootNodeId == 0x0) {\n                    rootNodeId = nodeId;\n                    index_to_root[indexId] = nodeId;\n                }\n                var currentNode = node_lookup[rootNodeId];\n\n                // Do insertion\n                while (true) {\n                    if (currentNode.indexId == 0x0) {\n                        // This is a new unpopulated node.\n                        currentNode.nodeId = nodeId;\n                        currentNode.parent = previousNodeId;\n                        currentNode.indexId = indexId;\n                        currentNode.id = id;\n                        currentNode.value = value;\n                        break;\n                    }\n\n                    // Set the previous node id.\n                    previousNodeId = currentNode.nodeId;\n\n                    // The new node belongs in the right subtree\n                    if (value >= currentNode.value) {\n                        if (currentNode.right == 0x0) {\n                            currentNode.right = nodeId;\n                        }\n                        currentNode = node_lookup[currentNode.right];\n                        continue;\n                    }\n\n                    // The new node belongs in the left subtree.\n                    if (currentNode.left == 0x0) {\n                        currentNode.left = nodeId;\n                    }\n                    currentNode = node_lookup[currentNode.left];\n                }\n\n                // Rebalance the tree\n                _rebalanceTree(currentNode.nodeId);\n        }\n\n        function exists(bytes32 indexId, bytes32 id) constant returns (bool) {\n            bytes32 nodeId = getNodeId(indexId, id);\n            return (node_lookup[nodeId].nodeId == nodeId);\n        }\n\n        function remove(bytes32 indexName, bytes32 id) public {\n            bytes32 indexId = getIndexId(msg.sender, indexName);\n            bytes32 nodeId = getNodeId(indexId, id);\n            \n            Node replacementNode;\n            Node parent;\n            Node child;\n            bytes32 rebalanceOrigin;\n\n            var nodeToDelete = node_lookup[nodeId];\n\n            if (nodeToDelete.id != id) {\n                // The id does not exist in the tree.\n                return;\n            }\n\n            if (nodeToDelete.left != 0x0 || nodeToDelete.right != 0x0) {\n                // This node is not a leaf node and thus must replace itself in\n                // it's tree by either the previous or next node.\n                if (nodeToDelete.left != 0x0) {\n                    // This node is guaranteed to not have a right child.\n                    replacementNode = node_lookup[getPreviousNode(nodeToDelete.nodeId)];\n                }\n                else {\n                    // This node is guaranteed to not have a left child.\n                    replacementNode = node_lookup[getNextNode(nodeToDelete.nodeId)];\n                }\n                // The replacementNode is guaranteed to have a parent.\n                parent = node_lookup[replacementNode.parent];\n\n                // Keep note of the location that our tree rebalancing should\n                // start at.\n                rebalanceOrigin = replacementNode.nodeId;\n\n                // Join the parent of the replacement node with any subtree of\n                // the replacement node.  We can guarantee that the replacement\n                // node has at most one subtree because of how getNextNode and\n                // getPreviousNode are used.\n                if (parent.left == replacementNode.nodeId) {\n                    parent.left = replacementNode.right;\n                    if (replacementNode.right != 0x0) {\n                        child = node_lookup[replacementNode.right];\n                        child.parent = parent.nodeId;\n                    }\n                }\n                if (parent.right == replacementNode.nodeId) {\n                    parent.right = replacementNode.left;\n                    if (replacementNode.left != 0x0) {\n                        child = node_lookup[replacementNode.left];\n                        child.parent = parent.nodeId;\n                    }\n                }\n\n                // Now we replace the nodeToDelete with the replacementNode.\n                // This includes parent/child relationships for all of the\n                // parent, the left child, and the right child.\n                replacementNode.parent = nodeToDelete.parent;\n                if (nodeToDelete.parent != 0x0) {\n                    parent = node_lookup[nodeToDelete.parent];\n                    if (parent.left == nodeToDelete.nodeId) {\n                        parent.left = replacementNode.nodeId;\n                    }\n                    if (parent.right == nodeToDelete.nodeId) {\n                        parent.right = replacementNode.nodeId;\n                    }\n                }\n                else {\n                    // If the node we are deleting is the root node so update\n                    // the indexId to root node mapping.\n                    index_to_root[indexId] = replacementNode.nodeId;\n                }\n\n                replacementNode.left = nodeToDelete.left;\n                if (nodeToDelete.left != 0x0) {\n                    child = node_lookup[nodeToDelete.left];\n                    child.parent = replacementNode.nodeId;\n                }\n\n                replacementNode.right = nodeToDelete.right;\n                if (nodeToDelete.right != 0x0) {\n                    child = node_lookup[nodeToDelete.right];\n                    child.parent = replacementNode.nodeId;\n                }\n            }\n            else if (nodeToDelete.parent != 0x0) {\n                // The node being deleted is a leaf node so we only erase it's\n                // parent linkage.\n                parent = node_lookup[nodeToDelete.parent];\n\n                if (parent.left == nodeToDelete.nodeId) {\n                    parent.left = 0x0;\n                }\n                if (parent.right == nodeToDelete.nodeId) {\n                    parent.right = 0x0;\n                }\n\n                // keep note of where the rebalancing should begin.\n                rebalanceOrigin = parent.nodeId;\n            }\n            else {\n                // This is both a leaf node and the root node, so we need to\n                // unset the root node pointer.\n                index_to_root[indexId] = 0x0;\n            }\n\n            // Now we zero out all of the fields on the nodeToDelete.\n            nodeToDelete.id = 0x0;\n            nodeToDelete.nodeId = 0x0;\n            nodeToDelete.indexId = 0x0;\n            nodeToDelete.value = 0;\n            nodeToDelete.parent = 0x0;\n            nodeToDelete.left = 0x0;\n            nodeToDelete.right = 0x0;\n\n            // Walk back up the tree rebalancing\n            if (rebalanceOrigin != 0x0) {\n                _rebalanceTree(rebalanceOrigin);\n            }\n        }\n\n        bytes2 constant GT = \">\";\n        bytes2 constant LT = \"<\";\n        bytes2 constant GTE = \">=\";\n        bytes2 constant LTE = \"<=\";\n        bytes2 constant EQ = \"==\";\n\n        function _compare(int left, bytes2 operator, int right) internal returns (bool) {\n            if (operator == GT) {\n                return (left > right);\n            }\n            if (operator == LT) {\n                return (left < right);\n            }\n            if (operator == GTE) {\n                return (left >= right);\n            }\n            if (operator == LTE) {\n                return (left <= right);\n            }\n            if (operator == EQ) {\n                return (left == right);\n            }\n\n            // Invalid operator.\n            __throw();\n        }\n\n        function _getMaximum(bytes32 nodeId) internal returns (int) {\n                var currentNode = node_lookup[nodeId];\n\n                while (true) {\n                    if (currentNode.right == 0x0) {\n                        return currentNode.value;\n                    }\n                    currentNode = node_lookup[currentNode.right];\n                }\n        }\n\n        function _getMinimum(bytes32 nodeId) internal returns (int) {\n                var currentNode = node_lookup[nodeId];\n\n                while (true) {\n                    if (currentNode.left == 0x0) {\n                        return currentNode.value;\n                    }\n                    currentNode = node_lookup[currentNode.left];\n                }\n        }\n\n        function query(bytes32 indexId, bytes2 operator, int value) public returns (bytes32) {\n                bytes32 rootNodeId = index_to_root[indexId];\n                \n                if (rootNodeId == 0x0) {\n                    // Empty tree.\n                    return 0x0;\n                }\n\n                var currentNode = node_lookup[rootNodeId];\n\n                while (true) {\n                    if (_compare(currentNode.value, operator, value)) {\n                        // We have found a match but it might not be the\n                        // *correct* match.\n                        if ((operator == LT) || (operator == LTE)) {\n                            // Need to keep traversing right until this is no\n                            // longer true.\n                            if (currentNode.right == 0x0) {\n                                return currentNode.nodeId;\n                            }\n                            if (_compare(_getMinimum(currentNode.right), operator, value)) {\n                                // There are still nodes to the right that\n                                // match.\n                                currentNode = node_lookup[currentNode.right];\n                                continue;\n                            }\n                            return currentNode.nodeId;\n                        }\n\n                        if ((operator == GT) || (operator == GTE) || (operator == EQ)) {\n                            // Need to keep traversing left until this is no\n                            // longer true.\n                            if (currentNode.left == 0x0) {\n                                return currentNode.nodeId;\n                            }\n                            if (_compare(_getMaximum(currentNode.left), operator, value)) {\n                                currentNode = node_lookup[currentNode.left];\n                                continue;\n                            }\n                            return currentNode.nodeId;\n                        }\n                    }\n\n                    if ((operator == LT) || (operator == LTE)) {\n                        if (currentNode.left == 0x0) {\n                            // There are no nodes that are less than the value\n                            // so return null.\n                            return 0x0;\n                        }\n                        currentNode = node_lookup[currentNode.left];\n                        continue;\n                    }\n\n                    if ((operator == GT) || (operator == GTE)) {\n                        if (currentNode.right == 0x0) {\n                            // There are no nodes that are greater than the value\n                            // so return null.\n                            return 0x0;\n                        }\n                        currentNode = node_lookup[currentNode.right];\n                        continue;\n                    }\n\n                    if (operator == EQ) {\n                        if (currentNode.value < value) {\n                            if (currentNode.right == 0x0) {\n                                return 0x0;\n                            }\n                            currentNode = node_lookup[currentNode.right];\n                            continue;\n                        }\n\n                        if (currentNode.value > value) {\n                            if (currentNode.left == 0x0) {\n                                return 0x0;\n                            }\n                            currentNode = node_lookup[currentNode.left];\n                            continue;\n                        }\n                    }\n                }\n        }\n\n        function _rebalanceTree(bytes32 nodeId) internal {\n            // Trace back up rebalancing the tree and updating heights as\n            // needed..\n            var currentNode = node_lookup[nodeId];\n\n            while (true) {\n                int balanceFactor = _getBalanceFactor(currentNode.nodeId);\n\n                if (balanceFactor == 2) {\n                    // Right rotation (tree is heavy on the left)\n                    if (_getBalanceFactor(currentNode.left) == -1) {\n                        // The subtree is leaning right so it need to be\n                        // rotated left before the current node is rotated\n                        // right.\n                        _rotateLeft(currentNode.left);\n                    }\n                    _rotateRight(currentNode.nodeId);\n                }\n\n                if (balanceFactor == -2) {\n                    // Left rotation (tree is heavy on the right)\n                    if (_getBalanceFactor(currentNode.right) == 1) {\n                        // The subtree is leaning left so it need to be\n                        // rotated right before the current node is rotated\n                        // left.\n                        _rotateRight(currentNode.right);\n                    }\n                    _rotateLeft(currentNode.nodeId);\n                }\n\n                if ((-1 <= balanceFactor) && (balanceFactor <= 1)) {\n                    _updateNodeHeight(currentNode.nodeId);\n                }\n\n                if (currentNode.parent == 0x0) {\n                    // Reached the root which may be new due to tree\n                    // rotation, so set it as the root and then break.\n                    break;\n                }\n\n                currentNode = node_lookup[currentNode.parent];\n            }\n        }\n\n        function _getBalanceFactor(bytes32 nodeId) internal returns (int) {\n                var node = node_lookup[nodeId];\n\n                return int(node_lookup[node.left].height) - int(node_lookup[node.right].height);\n        }\n\n        function _updateNodeHeight(bytes32 nodeId) internal {\n                var node = node_lookup[nodeId];\n\n                node.height = max(node_lookup[node.left].height, node_lookup[node.right].height) + 1;\n        }\n\n        function _rotateLeft(bytes32 nodeId) internal {\n            var originalRoot = node_lookup[nodeId];\n\n            if (originalRoot.right == 0x0) {\n                // Cannot rotate left if there is no right originalRoot to rotate into\n                // place.\n                __throw();\n            }\n\n            // The right child is the new root, so it gets the original\n            // `originalRoot.parent` as it's parent.\n            var newRoot = node_lookup[originalRoot.right];\n            newRoot.parent = originalRoot.parent;\n\n            // The original root needs to have it's right child nulled out.\n            originalRoot.right = 0x0;\n\n            if (originalRoot.parent != 0x0) {\n                // If there is a parent node, it needs to now point downward at\n                // the newRoot which is rotating into the place where `node` was.\n                var parent = node_lookup[originalRoot.parent];\n\n                // figure out if we're a left or right child and have the\n                // parent point to the new node.\n                if (parent.left == originalRoot.nodeId) {\n                    parent.left = newRoot.nodeId;\n                }\n                if (parent.right == originalRoot.nodeId) {\n                    parent.right = newRoot.nodeId;\n                }\n            }\n\n\n            if (newRoot.left != 0) {\n                // If the new root had a left child, that moves to be the\n                // new right child of the original root node\n                var leftChild = node_lookup[newRoot.left];\n                originalRoot.right = leftChild.nodeId;\n                leftChild.parent = originalRoot.nodeId;\n            }\n\n            // Update the newRoot's left node to point at the original node.\n            originalRoot.parent = newRoot.nodeId;\n            newRoot.left = originalRoot.nodeId;\n\n            if (newRoot.parent == 0x0) {\n                index_to_root[newRoot.indexId] = newRoot.nodeId;\n            }\n\n            // TODO: are both of these updates necessary?\n            _updateNodeHeight(originalRoot.nodeId);\n            _updateNodeHeight(newRoot.nodeId);\n        }\n\n        function _rotateRight(bytes32 nodeId) internal {\n            var originalRoot = node_lookup[nodeId];\n\n            if (originalRoot.left == 0x0) {\n                // Cannot rotate right if there is no left node to rotate into\n                // place.\n                __throw();\n            }\n\n            // The left child is taking the place of node, so we update it's\n            // parent to be the original parent of the node.\n            var newRoot = node_lookup[originalRoot.left];\n            newRoot.parent = originalRoot.parent;\n\n            // Null out the originalRoot.left\n            originalRoot.left = 0x0;\n\n            if (originalRoot.parent != 0x0) {\n                // If the node has a parent, update the correct child to point\n                // at the newRoot now.\n                var parent = node_lookup[originalRoot.parent];\n\n                if (parent.left == originalRoot.nodeId) {\n                    parent.left = newRoot.nodeId;\n                }\n                if (parent.right == originalRoot.nodeId) {\n                    parent.right = newRoot.nodeId;\n                }\n            }\n\n            if (newRoot.right != 0x0) {\n                var rightChild = node_lookup[newRoot.right];\n                originalRoot.left = newRoot.right;\n                rightChild.parent = originalRoot.nodeId;\n            }\n\n            // Update the new root's right node to point to the original node.\n            originalRoot.parent = newRoot.nodeId;\n            newRoot.right = originalRoot.nodeId;\n\n            if (newRoot.parent == 0x0) {\n                index_to_root[newRoot.indexId] = newRoot.nodeId;\n            }\n\n            // Recompute heights.\n            _updateNodeHeight(originalRoot.nodeId);\n            _updateNodeHeight(newRoot.nodeId);\n        }\n\n        function __throw() internal {\n            int[] x;\n            x[1];\n        }\n}\n",
            "userDoc": {
                "methods": {}
            }
        }
    }
}
